;; Implement functions to convert terms between MeTTa, lambda calculus
;; and combinatory logic.
;;
;; For the lambda calculus <-> combinatory logic part, the code is
;; inspired from the paper:
;;
;; A correct-by-construction conversion from lambda calculus to
;; combinatory logic, by Wouter Swierstra.
;;
;; As in the paper, the version of combinatory logic in consideration
;; is S, K, I.  In order not to have S, the combinator, be confused
;; with with S, the successor, we use the unicode characters ùêí, ùêä and
;; ùêà, as well as other similar unicode characters for more
;; combinators.  Also all functions are explicitly curried, thus ùêä x y
;; is represented in MeTTa as ((ùêä x) y).
;;
;; On the lambda-calculus side, the MeTTa representation of a lambda
;; abstraction is (Œª <VAR> <BODY>).  Applications are explicitly
;; curried as well, thus (x y z) is represented ((x y) z).
;;
;; An excellent source information about combinatory logic can be
;; found in this blog series
;;
;; https://farrugiamaths.quora.com/Combinatory-logic-Using-math-boldsymbol-mathsf-S-math-and-math-boldsymbol-mathsf-K-math-Part-1
;;
;; by Alexander Farrugia
;;
;; To test if our reduction rules and convertion algorithms between
;; lambda calculus and combinatory logic are correct we use arithmetic.
;;
;; For arithmetic in combinatory logic, see
;;
;; https://farrugiamaths.quora.com/Combinatory-logic-Natural-numbers-and-predicates-Part-6
;;
;; For arithmetic in lambda calculus, see
;;
;; https://en.wikipedia.org/wiki/Lambda_calculus#Arithmetic_in_lambda_calculus

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Common functions and types ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Define DeBruijn type
(: DeBruijn Type)

;; Define DeBruijn constructors
(: Z' DeBruijn)                        ; Zero
(: S' (-> DeBruijn DeBruijn))          ; Successor

;; Define Maybe type
(: Maybe (-> $a Type))
(: Nothing (Maybe $a))
(: Just (-> $a (Maybe $a)))

;; Define list type
(: List (-> $a Type))
(: Nil (List $a))
(: Cons (-> $a (List $a) (List $a)))

;; Define is-expression, a function that returns True iff the input is
;; a MeTTa expression, meaning it is not a symbol or a variable.
(: is-expression (-> Atom Bool))
(= (is-expression $x) (== (get-metatype $x) Expression))

;; Test is-expression
!(assertEqual (is-expression $x) False)
!(assertEqual (is-expression A) False)
!(assertEqual (is-expression (A B)) True)

;; Define is-variable, a function that returns True iff its input is a
;; MeTTa variable.
(: is-variable (-> Atom Bool))
(= (is-variable $x) (== (get-metatype $x) Variable))

;; Test is-variable
!(assertEqual (is-variable $x) True)
!(assertEqual (is-variable A) False)
!(assertEqual (is-variable (A $x)) False)

;; Define is-symbol, a function that returns True iff its input is a
;; MeTTa symbol.
(: is-symbol (-> Atom Bool))
(= (is-symbol $x) (== (get-metatype $x) Symbol))

;; Test is-symbol
!(assertEqual (is-symbol $x) False)
!(assertEqual (is-symbol A) True)
!(assertEqual (is-symbol (A $x)) False)

;; Till lazy or and and gets into the stdlib
(: lazy-or (-> Bool Atom Bool))
(= (lazy-or False $x) $x)
(= (lazy-or True $x) True)
(: lazy-and (-> Bool Atom Bool))
(= (lazy-and False $x) False)
(= (lazy-and True $x) $x)

;; Return True iff the first argument is a subterm of the second
;; argument.
;;
;; For instance
;;
;; (is-subterm-of A A) returns True
;; (is-subterm-of A (A B)) returns True
;; (is-subterm-of A B) returns False
;; (is-subterm-of A (B C)) returns False
;;
;; It should handle variables properly (that is assume that variables
;; with different names are different terms), for instance
;;
;; (is-subterm-of $x $x) returns True
;; (is-subterm-of $x ($x $y)) returns True
;; (is-subterm-of $x $y) returns False
;; (is-subterm-of $x ($y $z)) return False
;;
;; Terms can of course contain both symbols and variables, for
;; instance
;;
;; (is-subterm-of A ($x A)) returns True
;; (is-subterm-of $x ($x A)) returns True
;; (is-subterm-of A ($x B)) returns False
;; (is-subterm-of $x ($y A)) returns False
;;
;; It should of course detect a subterm when it is buried deeper
;; inside the superterm, for instance
;;
;; (is-subterm-of A (C (B A))) returns True
;; (is-subterm-of A (B (C D))) returns False
(: is-subterm-of (-> Atom Atom Bool))
(= (is-subterm-of $x $y)
   ;; Base cases
   (if (== $x $y)
       True
       (if (== $y ())
           False
           ;; Recursive step
           (if (is-expression $y)
               (lazy-or (let $head (car-atom $y) (is-subterm-of $x $head))
                        (let $tail (cdr-atom $y) (is-subterm-of $x $tail)))
               ;; Final base case
               False))))

;; Test is-subterm-of
!(assertEqual (is-subterm-of A A) True)
!(assertEqual (is-subterm-of A ()) False)
!(assertEqual (is-subterm-of A (A B)) True)
!(assertEqual (is-subterm-of A B) False)
!(assertEqual (is-subterm-of A (B C)) False)
!(assertEqual (is-subterm-of $x $x) True)
!(assertEqual (is-subterm-of $x ($x $y)) True)
!(assertEqual (is-subterm-of $x $y) False)
!(assertEqual (is-subterm-of $x ($y $z)) False)
!(assertEqual (is-subterm-of A ($x A)) True)
!(assertEqual (is-subterm-of $x ($x A)) True)
!(assertEqual (is-subterm-of A ($x B)) False)
!(assertEqual (is-subterm-of $x ($y A)) False)
!(assertEqual (is-subterm-of A (C (B A))) True)
!(assertEqual (is-subterm-of A (B (C D))) False)

;; Define Œ±-Binding type, that represents a binding from a variable to
;; another variable.
(: Œ±-Binding Type)
(: ‚ÜîŒ± (-> Variable Variable Œ±-Binding))

;; Insert an Œ±-binding in a list of Œ±-bindings.  Returns maybe the new
;; list of Œ±-bindings if the insertion succeeded, that is the
;; Œ±-binding is consistent with the list, or entirely missing from it.
(: Œ±-insert (-> Œ±-Binding (List Œ±-Binding) (Maybe (List Œ±-Binding))))
;; Base case
(= (Œ±-insert (‚ÜîŒ± $x $y) Nil) (Just (Cons (‚ÜîŒ± $x $y) Nil)))
;; Recursive step
(= (Œ±-insert (‚ÜîŒ± $x $y) (Cons (‚ÜîŒ± $z $w) $tail))
   (if (== $x $z)
       (if (== $y $w)
           (Just (Cons (‚ÜîŒ± $z $w) $tail))
           Nothing)
       (if (== $y $w)
           Nothing
           (case (Œ±-insert (‚ÜîŒ± $x $y) $tail)
             ((Nothing Nothing)
              ((Just $ŒΩtl) (Just (Cons (‚ÜîŒ± $z $w) $ŒΩtl))))))))

;; Test Œ±-insert
!(assertEqual
  (Œ±-insert (‚ÜîŒ± $x $y) Nil)
  (Just (Cons (‚ÜîŒ± $x $y) Nil)))
!(assertEqual
  (Œ±-insert (‚ÜîŒ± $x $y) (Cons (‚ÜîŒ± $x $y) Nil))
  (Just (Cons (‚ÜîŒ± $x $y) Nil)))
!(assertEqual
  (Œ±-insert (‚ÜîŒ± $x $y) (Cons (‚ÜîŒ± $x $z) Nil))
  Nothing)
!(assertEqual
  (Œ±-insert (‚ÜîŒ± $x $y) (Cons (‚ÜîŒ± $z $w) Nil))
  (Just (Cons (‚ÜîŒ± $z $w) (Cons (‚ÜîŒ± $x $y) Nil))))

;; Join two Œ±-bindings to produce an Œ±-bindings consisting of the
;; union of these.  If the two Œ±-bindings provided in input are
;; inconsistent, or one of them in Nothing, then return Nothing.
(: Œ±-join (-> (Maybe (List Œ±-Binding))
              (Maybe (List Œ±-Binding))
              (Maybe (List Œ±-Binding))))
;; Base cases
(= (Œ±-join Nothing Nothing) Nothing)
(= (Œ±-join Nothing (Just $_)) Nothing)
(= (Œ±-join (Just $_) Nothing) Nothing)
(= (Œ±-join (Just Nil) (Just $other)) (Just $other))
;; Recursive step
(= (Œ±-join (Just (Cons $head $tail)) (Just $other))
   (Œ±-join (Just $tail) (Œ±-insert $head $other)))

;; Test Œ±-join
!(assertEqual
  (Œ±-join Nothing Nothing)
  Nothing)
!(assertEqual
  (Œ±-join (Just Nil) (Just Nil))
  (Just Nil))
!(assertEqual
  (Œ±-join (Just Nil) (Just (Cons (‚ÜîŒ± $x $y) Nil)))
  (Just (Cons (‚ÜîŒ± $x $y) Nil)))
!(assertEqual
  (Œ±-join (Just (Cons (‚ÜîŒ± $x $y) Nil)) (Just Nil))
  (Just (Cons (‚ÜîŒ± $x $y) Nil)))
!(assertEqual
  (Œ±-join (Just Nil) (Just (Cons (‚ÜîŒ± $x $y) Nil)))
  (Just (Cons (‚ÜîŒ± $x $y) Nil)))
!(assertEqual
  (Œ±-join (Just (Cons (‚ÜîŒ± $x $y) Nil)) (Just (Cons (‚ÜîŒ± $x $z) Nil)))
  Nothing)
!(assertEqual
  (Œ±-join (Just (Cons (‚ÜîŒ± $x $y) Nil)) (Just (Cons (‚ÜîŒ± $x $y) Nil)))
  (Just (Cons (‚ÜîŒ± $x $y) Nil)))
!(assertEqual
  (Œ±-join (Just (Cons (‚ÜîŒ± $x $y) Nil)) (Just (Cons (‚ÜîŒ± $z $w) Nil)))
  (Just (Cons (‚ÜîŒ± $z $w) (Cons (‚ÜîŒ± $x $y) Nil))))

;; Given two terms, $lhs and $rhs, return maybe a list of Œ±-bindings
;; so that if $lhs is Œ±-equivalent to $rhs, substituting all variables
;; in $rhs according to the Œ±-bindings would result in a term that is
;; equal to $lhs.  If $lhs and $rhs are not Œ±-equivalent then return
;; Nothing.
(: Œ±-bindings (-> Atom Atom (Maybe (List Œ±-Binding))))
(= (Œ±-bindings $lhs $rhs)
   (case (get-metatype $lhs)
     ((Symbol (if (== $lhs $rhs)
                  (Just Nil)
                  Nothing))
      (Grounded (if (== $lhs $rhs)
                    (Just Nil)
                    Nothing))
      (Variable (if (is-variable $rhs)
                    (Just (Cons (‚ÜîŒ± $lhs $rhs) Nil))
                    Nothing))
      (Expression (if (== $lhs ())
                      ;; $lhs is ()
                      (if (== $rhs ())
                          (Just Nil)
                          Nothing)
                      ;; $lhs is not ()
                      (if (== $rhs ())
                          Nothing
                          (case (get-metatype $rhs)
                            ((Symbol Nothing)
                             (Grounded Nothing)
                             (Variable Nothing)
                             (Expression
                              (let* (($hd-lhs (car-atom $lhs))
                                     ($tl-lhs (cdr-atom $lhs))
                                     ($hd-rhs (car-atom $rhs))
                                     ($tl-rhs (cdr-atom $rhs))
                                     ($hd-Œ±-bs (Œ±-bindings $hd-lhs $hd-rhs))
                                     ($tl-Œ±-bs (Œ±-bindings $tl-lhs $tl-rhs)))
                                (Œ±-join $hd-Œ±-bs $tl-Œ±-bs)))))))))))

;; Test Œ±-bindings
!(assertEqual
  (Œ±-bindings A B)
  Nothing)
!(assertEqual
  (Œ±-bindings $x B)
  Nothing)
!(assertEqual
  (Œ±-bindings () ())
  (Just Nil))
!(assertEqual
  (Œ±-bindings (R $x) $y)
  Nothing)
!(assertEqual
  (Œ±-bindings $x $y)
  (Just (Cons (‚ÜîŒ± $x $y) Nil)))
!(assertEqual
  (Œ±-bindings (R $x) (R $y))
  (Just (Cons (‚ÜîŒ± $x $y) Nil)))
!(assertEqual
  (Œ±-bindings ((R $x) A) ((R $y) $z))
  Nothing)
!(assertEqual
  (Œ±-bindings ((R $x) $x) ((R $z) $w))
  Nothing)
!(assertEqual
  (Œ±-bindings ((R $x) $y) ((R $z) $z))
  Nothing)
!(assertEqual
  (Œ±-bindings (R $x (R $y)) (R $z $z))
  Nothing)
!(assertEqual
  (Œ±-bindings ((R $x) $y) ((R $z) $w))
  (Just (Cons (‚ÜîŒ± $y $w) (Cons (‚ÜîŒ± $x $z) Nil))))

;; Return True iff two given terms are alpha-equivalent.  For now all
;; variables are assumed to be free, the notion of scope is not
;; implemented.
(: =Œ± (-> $a $b Bool))
(= (=Œ± $lhs $rhs) (case (Œ±-bindings $lhs $rhs)
                    ((Nothing False)
                     ((Just $_) True))))

;; Test =Œ±
!(assertEqual (=Œ± $x $x) True)
!(assertEqual (=Œ± $x $y) True)
!(assertEqual (=Œ± A B) False)
!(assertEqual (=Œ± A $y) False)
!(assertEqual (=Œ± (R $x) (R $y)) True)
!(assertEqual (=Œ± (R $x $x) (R $y $z)) False)
!(assertEqual (=Œ± (R $x (R $y)) (R $z $z)) False)
!(assertEqual (=Œ± (Œª $x (Œª $y $x)) (Œª $z (Œª $w $z))) True)

;;;;;;;;;;;;;;;;;;;;;
;; Reduction rules ;;
;;;;;;;;;;;;;;;;;;;;;

;; Due to double-sided matching, combinatory logic and lambda calculus
;; reduction rules cannot be emulated that easily.  Instead a reduce
;; function is implemented instead.

;; Reduce lambda application
;; (: Œª (-> Variable $a (-> $b $c))) ; Problemantic for =Œ± (no idea why)
;; (: Œª (-> Variable Atom Atom)) ; Problematic for reduction
;; (= ((Œª $x $f) $y) (let ($ŒΩx $ŒΩf) (sealed ($x) ($x $f)) (let $ŒΩx $y $ŒΩf)))

;; ;; Test lambda calculus reduction
;; !(assertEqual
;;   $x
;;   $x)
;; !(assertEqual
;;   ($f $x)
;;   ($f $x))
;; !(assertEqual
;;   (Œª $x ($f $x))
;;   (Œª $x ($f $x)))
;; !(assertEqual
;;   ((Œª $x $x) $y)
;;   $y)
;; !(assertEqual
;;   ((Œª $x $x) (Œª $x $x))
;;   (Œª $x $x))
;; !(assertEqual
;;   ((Œª $f (Œª $x $x)) $g)
;;   (Œª $x $x))
;; !(assertEqual
;;   (Œª $f (Œª $x $x))                       ; 0
;;   (Œª $f (Œª $x $x)))
;; !(assertEqual
;;   (Œª $f (Œª $x ($f $x)))                  ; 1
;;   (Œª $f (Œª $x ($f $x))))
;; !(assertEqual
;;   (Œª $n (Œª $f (Œª $x ($f (($n $f) $x))))) ; Successor
;;   (Œª $n (Œª $f (Œª $x ($f (($n $f) $x))))))
;; ;; NEXT: re-enable assertEqual when duplicates are fixed.
;; ;; See issue https://github.com/trueagi-io/hyperon-experimental/issues/235
;; !(assertEqual
;;   ((Œª $n (Œª $f (Œª $x (($n $x) ($f $x))))) ; ùêí
;;    (Œª $y (Œª $z (Œª $w ($y ($z $w))))))     ; ùêÅ
;;   (Œª $f (Œª $x (Œª $w ($x (($f $x) $w)))))) ; Successor
;; ;; NEXT: re-enable assertEqual when duplicates are fixed.
;; ;; See issue https://github.com/trueagi-io/hyperon-experimental/issues/235
;; ;; !(assertEqual
;; !((Œª $n (Œª $f (Œª $x ($f (($n $f) $x)))))
;;   (Œª $f (Œª $x $x))) ; 1, successor of 0
;; ;; (Œª $f (Œª $x ($f $x))))
;; ;; !(assertEqual
;; !((Œª $n (Œª $f (Œª $x ($f (($n $f) $x)))))  ; Successor
;;   ((Œª $n (Œª $f (Œª $x ($f (($n $f) $x))))) ; Successor
;;    (Œª $f (Œª $x $x))))                     ; 0
;; ;; (Œª $f (Œª $x ($f ($f $x)))))            ; 2, the result of (Succ (Succ 0))
;; !(assertEqual
;;   (Œª $m (Œª $n (Œª $f (Œª $x (($m $f) (($n $f) $x)))))) ; Plus
;;   (Œª $m (Œª $n (Œª $f (Œª $x (($m $f) (($n $f) $x)))))))
;; ;; NEXT: re-enable assertEqual when duplicates are fixed.
;; ;; See issue https://github.com/trueagi-io/hyperon-experimental/issues/235
;; ;; !(assertEqual
;;  !((Œª $m (Œª $n (Œª $f (Œª $x (($m $f) (($n $f) $x)))))) ; Plus
;;    (Œª $f (Œª $x $x)))                                  ; 0
;;   ;; (Œª $n (Œª $f (Œª $x (($n $f) $x)))))  ; (Plus 0)
;; ;; !(assertEqual
;;   !(((Œª $m (Œª $n (Œª $f (Œª $x (($m $f) (($n $f) $x)))))) ; Plus
;;     (Œª $f (Œª $x $x)))                                  ; 0
;;    (Œª $f (Œª $x $x)))                                   ; 0
;; ;;   (Œª $f (Œª $x $x)))  ; 0, the result of (Plus 0 0)
;; ;; !(assertEqual
;;  !(((Œª $m (Œª $n (Œª $f (Œª $x (($m $f) (($n $f) $x)))))) ; Plus
;;     (Œª $f (Œª $x ($f $x))))                             ; 1
;;    (Œª $f (Œª $x ($f ($f $x)))))                         ; 2
;; ;;   (Œª $f (Œª $x ($f ($f ($f $x))))))  ; 3, the result of (Plus 1 2)

;; Reduction rules for combinatory logic.  In the process, we
;; introduce combinators ùêå, ùêç, ùêì, ùêñ, ùêÅ, ùêÇ and ùêî.
;; (= (ùêà $x) $x)
;; (= ((ùêä $x) $y) $x)
;; (= (((ùêí $x) $y) $z) (($x $z) ($y $z)))
;; (= (ùêå $x) ($x $x))
;; (= ((ùêç $x) $y) $y)
;; (= ((ùêì $x) $y) ($y $x))
;; (= ((ùêñ $x) $y) (($x $y) $y))
;; (= (((ùêÅ $x) $y) $z) ($x ($y $z)))
;; (= (((ùêÇ $x) $y) $z) (($x $z) $y))
;; (= ((ùêî $x) $y) ($y (($x $x) $y)))
;; (= ((ùêí ùêä) ùêä) ùêà)
;; (= ((ùêí (ùêä ùêä)) ùêà) ùêä)
;; (= ((ùêí ùêà) ùêà) ùêå)
;; (= (ùêä ùêà) ùêç)
;; (= ((ùêí (ùêä (ùêí ùêà))) ùêä) ùêì)
;; (= ((ùêí ùêí) ùêç) ùêñ)
;; (= ((ùêí (ùêä ùêí)) ùêä) ùêÅ)
;; (= ((ùêí (ùêÅ ùêÅ ùêí)) (ùêä ùêä)) ùêÇ)
;; (= ((ùêÅ (ùêí ùêà)) (ùêí ùêà ùêà)) ùêî)

;; ;; Test combinatory logic reduction
;; !(assertEqual
;;   (ùêä ùêà)                                 ; 0
;;   ùêç)
;; !(assertEqual
;;   ((ùêí (ùêä ùêä)) ùêà)
;;   ùêä)
;; !(assertEqual
;;   ((ùêí (ùêä ùêí)) ùêä)
;;   ùêÅ)
;; !(assertEqual
;;   ((ùêí ùêí) (ùêä ùêà))
;;   ùêñ)
;; !(assertEqual
;;   ((ùêí ùêí) ùêç)
;;   ùêñ)
;; !(assertEqual
;;   (ùêí ((ùêí (ùêä ùêí)) ùêä))                    ; Successor
;;   (ùêí ùêÅ))
;; !(assertEqual
;;   ((ùêí ((ùêí (ùêä ùêí)) ùêä)) (ùêä ùêà))            ; 1, as (Successor 0)
;;   ((ùêí ùêÅ) ùêç))
;; !(assertEqual
;;   ((ùêí ((ùêí (ùêä ùêí)) ùêä)) ((ùêí ((ùêí (ùêä ùêí)) ùêä)) (ùêä ùêà))) ; 2, as (Successor (Successor 0))
;;   ((ùêí ùêÅ) ((ùêí ùêÅ) ùêç)))
;; !(assertEqual
;;   (((ùêí (ùêä (ùêí ùêà))) ùêä) (ùêí ((ùêí (ùêä ùêí)) ùêä))) ; Plus
;;   (ùêì (ùêí ùêÅ)))
;; !(assertEqual
;;   ((((ùêí ùêà) (ùêä (ùêí ùêÅ))) ùêç) ùêç)             ; Apparently this is equivalent to (Plus 0 0)
;;   ùêç)
;; !(assertEqual
;;   (((ùêì (ùêí ùêÅ)) ùêç) ùêç)
;;   ùêç)
;; !(assertEqual
;;   (((((ùêí (ùêä (ùêí ùêà))) ùêä) (ùêí ((ùêí (ùêä ùêí)) ùêä))) (ùêä ùêà)) (ùêä ùêà)) ; 0, as (Plus 0 0)
;;   ùêç)
;; !(assertEqual
;;   (((((ùêí (ùêä (ùêí ùêà))) ùêä) (ùêí ((ùêí (ùêä ùêí)) ùêä))) ((ùêí ((ùêí (ùêä ùêí)) ùêä)) (ùêä ùêà)))
;;    ((ùêí ((ùêí (ùêä ùêí)) ùêä)) ((ùêí ((ùêí (ùêä ùêí)) ùêä)) (ùêä ùêà)))) ; 3, as (Plus 1 2)
;;   ((ùêí ùêÅ) ((ùêí ùêÅ) ((ùêí ùêÅ) ùêç))))

;; Reduce (ùêà $x) to $x
(: ùêà-reduce (-> $a (Maybe $a)))
(= (ùêà-reduce $term)
   (case $term
     ((($i $x) (if (== $i ùêà) (Just $x) Nothing))
      ($_ Nothing))))

;; Reduce ((ùêä $x) $y) to $x
(: ùêä-reduce (-> $a (Maybe $a)))
(= (ùêä-reduce $term)
   (case $term
     (((($k $x) $y) (if (== $k ùêä) (Just $x) Nothing))
      ($_ Nothing))))

;; Reduce (((ùêí $x) $y) $z) to (($x $z) ($y $z))
(: ùêí-reduce (-> $a (Maybe $a)))
(= (ùêí-reduce $term)
   (case $term
     ((((($s $x) $y) $z) (if (== $s ùêí) (Just (($x $z) ($y $z))) Nothing))
      ($_ Nothing))))

;; Reduce (ùêå $x) to ($x $x)
(: ùêå-reduce (-> $a (Maybe $a)))
(= (ùêå-reduce $term)
   (case $term
     ((($m $x) (if (== $m ùêå) (Just ($x $x)) Nothing))
      ($_ Nothing))))

;; Reduce ((ùêç $x) $y) to $y
(: ùêç-reduce (-> $a (Maybe $a)))
(= (ùêç-reduce $term)
   (case $term
     (((($n $x) $y) (if (== $n ùêç) (Just $y) Nothing))
      ($_ Nothing))))

;; Reduce ((ùêì $x) $y) to ($y $x)
(: ùêì-reduce (-> $a (Maybe $a)))
(= (ùêì-reduce $term)
   (case $term
     (((($t $x) $y) (if (== $t ùêì) (Just ($y $x)) Nothing))
      ($_ Nothing))))

;; Reduce ((ùêñ $x) $y) to (($x $y) $y)
(: ùêñ-reduce (-> $a (Maybe $a)))
(= (ùêñ-reduce $term)
   (case $term
     (((($w $x) $y) (if (== $w ùêñ) (Just (($x $y) $y)) Nothing))
      ($_ Nothing))))

;; Reduce (((ùêÅ $x) $y) $z) to ($x ($y $z))
(: ùêÅ-reduce (-> $a (Maybe $a)))
(= (ùêÅ-reduce $term)
   (case $term
     ((((($b $x) $y) $z) (if (== $b ùêÅ) (Just ($x ($y $z))) Nothing))
      ($_ Nothing))))

;; Reduce (((ùêÇ $x) $y) $z) to (($x $z) $y)
(: ùêÇ-reduce (-> $a (Maybe $a)))
(= (ùêÇ-reduce $term)
   (case $term
     ((((($c $x) $y) $z) (if (== $c ùêÇ) (Just (($x $z) $y)) Nothing))
      ($_ Nothing))))

;; Reduce ((ùêî $x) $y) to ($y (($x $x) $y))
(: ùêî-reduce (-> $a (Maybe $a)))
(= (ùêî-reduce $term)
   (case $term
     (((($u $x) $y) (if (== $u ùêî) (Just ($y (($x $x) $y))) Nothing))
      ($_ Nothing))))

;; Reduce ((Œª $x $y) $z) to (let ($ŒΩx $ŒΩy) (sealed ($x) ($x $y)) (reduce (let $ŒΩx $z $ŒΩy)))
(: Œ≤-reduce (-> $a (Maybe $a)))
(= (Œ≤-reduce $term)
   (case $term
     (((($l $x $y) $z) (if (== $l Œª) (Just (let ($ŒΩx $ŒΩy) (sealed ($x) ($x $y))
                                                (let $ŒΩx $z $ŒΩy))) Nothing))
      ($_ Nothing))))

;; Explicit reduction of combinatory logic and lambda calculus terms
;; to work around the lack of one-sided matching in reduction
(: reduce (-> $a $a))
(= (reduce $term)
   (case (get-metatype $term)
     ((Symbol $term)
      (Grounded $term)
      (Variable $term)
      (Expression
       ;; Base cases
       (if (== $term ())
           ()
           (if (== $term ((ùêí ùêä) ùêä))
               ùêà
               (if (== $term ((ùêí (ùêä ùêä)) ùêà))
                   ùêä
                   (if (== $term ((ùêí ùêà) ùêà))
                       ùêå
                       (if (== $term (ùêä ùêà))
                           ùêç
                           (if (== $term ((ùêí (ùêä (ùêí ùêà))) ùêä))
                               ùêì
                               (if (== $term ((ùêí ùêí) ùêç))
                                   ùêñ
                                   (if (== $term ((ùêí (ùêä ùêí)) ùêä))
                                       ùêÅ
                                       (if (== $term ((ùêí (ùêÅ ùêÅ ùêí)) (ùêä ùêä)))
                                           ùêÇ
                                           (if (== $term ((ùêÅ (ùêí ùêà)) (ùêí ùêà ùêà)))
                                               ùêî
                                               ;; Recursive steps
                                               (case $term
                                                 ;; Application
                                                 ((($f $g) (let* (($ŒΩf (reduce $f))
                                                                  ($ŒΩg (reduce $g)))
                                                             (if (and (== $ŒΩf $f) (== $ŒΩg $g))
                                                                 ;; $f and $g are already reduced,
                                                                 ;; try to match them to an known reduction rule
                                                                 (case (ùêà-reduce $term)
                                                                   (((Just $r) $r)
                                                                    (Nothing
                                                                     (case (ùêä-reduce $term)
                                                                       (((Just $r) $r)
                                                                        (Nothing
                                                                         (case (ùêí-reduce $term)
                                                                           (((Just $r) (reduce $r))
                                                                            (Nothing
                                                                             (case (ùêå-reduce $term)
                                                                               (((Just $r) (reduce $r))
                                                                                (Nothing
                                                                                 (case (ùêç-reduce $term)
                                                                                   (((Just $r) $r)
                                                                                    (Nothing
                                                                                     (case (ùêì-reduce $term)
                                                                                       (((Just $r) (reduce $r))
                                                                                        (Nothing
                                                                                         (case (ùêñ-reduce $term)
                                                                                           (((Just $r) (reduce $r))
                                                                                            (Nothing
                                                                                             (case (ùêÅ-reduce $term)
                                                                                               (((Just $r) (reduce $r))
                                                                                                (Nothing
                                                                                                 (case (ùêÇ-reduce $term)
                                                                                                   (((Just $r) (reduce $r))
                                                                                                    (Nothing
                                                                                                     (case (ùêî-reduce $term)
                                                                                                       (((Just $r) (reduce $r))
                                                                                                        (Nothing
                                                                                                         (case (Œ≤-reduce $term)
                                                                                                           (((Just $r) (reduce $r))
                                                                                                            ;; No known reduction rule,
                                                                                                            ;; Return as it is
                                                                                                            (Nothing ($f $g))))
                                                                                                         )))
                                                                                                     )))
                                                                                                 )))
                                                                                             )))
                                                                                         )))
                                                                                     )))
                                                                                 )))
                                                                             )))
                                                                         )))
                                                                     )))
                                                                 (reduce ($ŒΩf $ŒΩg)))))
                                                  ;; Abstraction
                                                  ((Œª $x $f) (Œª $x (reduce $f)))))))))))))))))))

;; Test reduce on combinatory logic
!(assertEqual
  (reduce ùêí)
  ùêí)
!(assertEqual
  (reduce ((ùêí (ùêä ùêä)) ùêà))
  ùêä)
!(assertEqual
  (reduce (ùêä ùêà))                          ; 0
  ùêç)
!(assertEqual
  (reduce (ùêí ùêí))
  (ùêí ùêí))
!(assertEqual
  (reduce ((ùêí (ùêä ùêí)) ùêä))
  ùêÅ)
!(assertEqual
  (reduce ((ùêí (ùêä (ùêí ùêà))) ùêä))
  ùêì)
!(assertEqual
  (reduce ((ùêí ùêí) (ùêä ùêà)))
  ùêñ)
!(assertEqual
  (reduce ((ùêí ùêí) ùêç))
  ùêñ)
!(assertEqual
  (reduce (ùêí ((ùêí (ùêä ùêí)) ùêä)))             ; Successor
  (ùêí ùêÅ))
!(assertEqual
  (reduce ((ùêí ((ùêí (ùêä ùêí)) ùêä)) (ùêä ùêà)))     ; 1, as (Successor 0)
  ((ùêí ùêÅ) ùêç))
!(assertEqual
  (reduce ((ùêí ((ùêí (ùêä ùêí)) ùêä)) ((ùêí ((ùêí (ùêä ùêí)) ùêä)) (ùêä ùêà)))) ; 2, as (Successor (Successor 0))
  ((ùêí ùêÅ) ((ùêí ùêÅ) ùêç)))
!(assertEqual
  (reduce (ùêì (ùêí ùêÅ))) ; Plus
  (ùêì (ùêí ùêÅ)))
!(assertEqual
  (reduce (ùêì (ùêí ((ùêí (ùêä ùêí)) ùêä)))) ; Plus
  (ùêì (ùêí ùêÅ)))
!(assertEqual
  (reduce (((ùêí (ùêä (ùêí ùêà))) ùêä) (ùêí ((ùêí (ùêä ùêí)) ùêä)))) ; Plus
  (ùêì (ùêí ùêÅ)))
!(assertEqual
  (reduce ((((ùêí ùêà) (ùêä (ùêí ùêÅ))) ùêç) ùêç))    ; Apparently this is equivalent to (Plus 0 0)
  ùêç)
!(assertEqual
  (reduce (((ùêì (ùêí ùêÅ)) ùêç) ùêç))            ; 0, as (Plus 0 0)
  ùêç)
!(assertEqual
  (reduce (((((ùêí (ùêä (ùêí ùêà))) ùêä) (ùêí ((ùêí (ùêä ùêí)) ùêä))) (ùêä ùêà)) (ùêä ùêà))) ; 0, as (Plus 0 0)
  ùêç)
!(assertEqual
  (reduce (((((ùêí (ùêä (ùêí ùêà))) ùêä) (ùêí ((ùêí (ùêä ùêí)) ùêä))) ((ùêí ((ùêí (ùêä ùêí)) ùêä)) (ùêä ùêà)))
           ((ùêí ((ùêí (ùêä ùêí)) ùêä)) ((ùêí ((ùêí (ùêä ùêí)) ùêä)) (ùêä ùêà))))) ; 3, as (Plus 1 2)
  ((ùêí ùêÅ) ((ùêí ùêÅ) ((ùêí ùêÅ) ùêç))))

;; Test reduce on lambda calculus
!(assertEqual
  (reduce $x)
  $x)
!(assertEqual
  (reduce ($x $x))
  ($x $x))
!(assertEqual
  (reduce ($f $x))
  ($f $x))
!(assertEqual
  (reduce (Œª $x ($f $x)))
  (Œª $x ($f $x)))
!(assertEqual
  (reduce ((Œª $x $x) $y))
  $y)
!(assertEqual
  (reduce ((Œª $x $x) (Œª $x $x)))
  (Œª $x $x))
!(assertEqual
  (reduce ((Œª $f (Œª $x $x)) $g))
  (Œª $x $x))
!(assertEqual
  (reduce (Œª $f (Œª $x $x)))                       ; 0
  (Œª $f (Œª $x $x)))
!(assertEqual
  (reduce (Œª $f (Œª $x ($f $x))))                  ; 1
  (Œª $f (Œª $x ($f $x))))
!(assertEqual
  !(reduce (($n $f) $x)) ; Successor subsubsubsubterm
  (($n $f) $x))
!(assertEqual
  !(reduce ($f (($n $f) $x))) ; Successor subsubsubterm
  ($f (($n $f) $x)))
!(assertEqual
  !(reduce (Œª $x ($f (($n $f) $x)))) ; Successor subsubterm
  (Œª $x ($f (($n $f) $x))))
!(assertEqual
  !(reduce (Œª $f (Œª $x ($f (($n $f) $x))))) ; Successor subterm
  (Œª $f (Œª $x ($f (($n $f) $x)))))
!(assertEqual
  !(reduce (Œª $n (Œª $f (Œª $x ($f (($n $f) $x)))))) ; Successor
  (Œª $n (Œª $f (Œª $x ($f (($n $f) $x))))))
;; NEXT: re-enable assertEqual when duplicates are fixed.
;; See issue https://github.com/trueagi-io/hyperon-experimental/issues/235
;; !(assertEqual
!(reduce ((Œª $n (Œª $f (Œª $x ($f (($n $f) $x)))))
          (Œª $f (Œª $x $x)))) ; 1, successor of 0
;; (Œª $f (Œª $x ($f $x))))
;; !(assertEqual
!(reduce ((Œª $n (Œª $f (Œª $x ($f (($n $f) $x)))))  ; Successor
          ((Œª $n (Œª $f (Œª $x ($f (($n $f) $x))))) ; Successor
           (Œª $f (Œª $x $x)))))                    ; 0
;; (Œª $f (Œª $x ($f ($f $x)))))  ; 2, the result of (Succ (Succ 0))
!(assertEqual
  (reduce (Œª $m (Œª $n (Œª $f (Œª $x (($m $f) (($n $f) $x))))))) ; Plus
  (Œª $m (Œª $n (Œª $f (Œª $x (($m $f) (($n $f) $x)))))))
;; NEXT: re-enable assertEqual when duplicates are fixed.
;; See issue https://github.com/trueagi-io/hyperon-experimental/issues/235
!(assertEqual
  (reduce (((Œª $m (Œª $n (Œª $f (Œª $x (($m $f) (($n $f) $x)))))) ; Plus
            (Œª $f (Œª $x $x)))                                  ; 0
           (Œª $f (Œª $x $x))))                                  ; 0
  (Œª $f (Œª $x $x)))  ; 0, the result of (Plus 0 0)
!(assertEqual
  (reduce (((Œª $m (Œª $n (Œª $f (Œª $x (($m $f) (($n $f) $x)))))) ; Plus
            (Œª $f (Œª $x ($f $x))))                             ; 1
           (Œª $f (Œª $x ($f ($f $x))))))                        ; 2
  (Œª $f (Œª $x ($f ($f ($f $x))))))  ; 3, the result of (Plus 1 2)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Combinatory logic to Œª-calculus ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Convert combinatory logic to lambda-calculus
(: cl2lc (-> $a $a))
;; Base cases
(= (cl2lc $term)
   (case (get-metatype $term)
     ((Symbol (case $term
                ((ùêà (Œª $x $x))
                 (ùêä (Œª $x (Œª $y $x)))
                 (ùêí (Œª $f (Œª $g (Œª $x (($f $x) ($g $x))))))
                 (ùêå (Œª $x ($x $x)))
                 (ùêç (Œª $x (Œª $y $y)))
                 (ùêì (Œª $x (Œª $y ($y $x))))
                 (ùêñ (Œª $x (Œª $y (($x $y) $y))))
                 (ùêÅ (Œª $x (Œª $y (Œª $z ($x ($y $z))))))
                 (ùêÇ (Œª $x (Œª $y (Œª $z (($x $z) $y)))))
                 (ùêî (Œª $x (Œª $y ($y (($x $x) $y)))))
                 ($_ $term))))
      (Variable $term)
      (Grounded $term)
      (Expression (if (== $term ())
                      ()
                      (case $term
                        ((($f $g) ((cl2lc $f) (cl2lc $g)))
                         ($_ $term))))))))

;; Test cl2lc
!(assertEqual
  (=Œ± (cl2lc ùêç) (Œª $f (Œª $x $x)))       ; 0
  True)
!(assertEqual
  (=Œ± (cl2lc (ùêí ùêÅ))
      ((Œª $n (Œª $f (Œª $x (($n $x) ($f $x))))) ; ùêí
       (Œª $y (Œª $z (Œª $w ($y ($z $w)))))))    ; ùêÅ
  True)
!(assertequal
  (=Œ± (reduce (cl2lc (ùêí ùêÅ)))
      (Œª $n (Œª $f (Œª $x ($f (($n $f) $x)))))) ; Successor
  True)
!(assertEqual
  (=Œ± (reduce (cl2lc ((ùêí ùêÅ) ùêç)))                      ; (Succ 0)
      (reduce ((Œª $n (Œª $f (Œª $x ($f (($n $f) $x)))))  ; Successor
               (Œª $f (Œª $x $x)))))                     ; 0
  True)
!(assertEqual
  (=Œ± (reduce (cl2lc ((ùêí ùêÅ) ùêç)))       ; (Succ 0)
      (Œª $f (Œª $x ($f $x))))            ; 1, as (Succ 0)
  True)
!(assertEqual
  (=Œ± (reduce (cl2lc (((ùêì (ùêí ùêÅ)) ùêç) ùêç)))  ; (Plus 0 0)
      (Œª $f (Œª $x $x)))                     ; 0
  True)
!(assertEqual
  (=Œ± (reduce (cl2lc (((ùêì (ùêí ùêÅ)) ((ùêí ùêÅ) ùêç)) ((ùêí ùêÅ) ((ùêí ùêÅ) ùêç))))) ; (Plus 1 2)
      (Œª $f (Œª $x ($f ($f ($f $x))))))                              ; 3
  True)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Œª-calculus to combinatory logic ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Convert lambda-calculus to combinatory logic
(: lc2cl (-> Atom Number Atom Atom))
(= (lc2cl $term $cnt $dir)
   (if (is-expression $term)
       (if (== $term ())
           ;; Base cases
           (trace! (bas-‚àÖ (term $term) (cnt $cnt) (dir $dir)) ())
           ;; Recursive steps
           (case $term
             (((Œª $x $f)
               (if (is-variable $x)
                   (if (== $f $x)
                       ;; Base case
                       (trace! (bas-I (term $term) (cnt $cnt) (dir $dir)) ùêà)
                       ;; Recursive steps
                       (let $clf (lc2cl $f (+ 1 $cnt) ŒªC)
                         (if (is-subterm-of $x $f)
                             ; Build ùêí
                             (trace! (rec-S (term $term) (clf $clf) (cnt $cnt) (dir $dir))
                                     (if (is-expression $clf)
                                         (case $clf
                                           ((($g $h) ((ùêí (lc2cl (Œª $x $g) (+ 2 $cnt) ŒªL))
                                                      (lc2cl (Œª $x $h) (+ 2 $cnt) ŒªR)))
                                                ($_ (empty))))
                                         $clf))
                             ; Build ùêä
                             (trace! (rec-K (term $term) (clf $clf) (cnt $cnt) (dir $dir))
                                     (ùêä $clf)))))
                   (empty)))
              (($f $g) (trace! (rec-app (term $term) (cnt $cnt) (dir $dir))
                               ((lc2cl $f (+ 1 $cnt) L) (lc2cl $g (+ 1 $cnt) R)))))))
           (trace! (bas-nch (term $term) (cnt $cnt) (dir $dir)) $term)))

;; ;; Convert lambda-calculus to combinatory logic
;; (: lc2cl (-> Atom Number Atom Atom))
;; (= (lc2cl $term $cnt $dir)
;;    (if (is-expression $term)
;;        (if (== $term ())
;;            ;; Base cases
;;            (trace! (bas-‚àÖ (term $term) (cnt $cnt) (dir $dir)) ())
;;            ;; NEXT: try to get rid of as many base cases as possible
;;            (if (=Œ± $term (Œª $x $x))
;;                (trace! (bas-I (term $term) (cnt $cnt) (dir $dir)) ùêà)
;;                (if (=Œ± $term (Œª $x (Œª $y $x)))
;;                    (trace! (bas-K (term $term) (cnt $cnt) (dir $dir)) ùêä)
;;                    (if (=Œ± $term (Œª $f (Œª $g (Œª $x (($f $x) ($g $x))))))
;;                        (trace! (bas-S (term $term) (cnt $cnt) (dir $dir)) ùêí)
;;                        (if (=Œ± $term (Œª $x ($x $x)))
;;                            (trace! (bas-M (term $term) (cnt $cnt) (dir $dir)) ùêå)
;;                            ;; Recursive steps
;;                            (case $term
;;                              (((Œª $x $f)
;;                                (if (is-variable $x)
;;                                    (let $clf (lc2cl $f (+ 1 $cnt) ŒªC)
;;                                      (if (is-subterm-of $x $f)
;;                                          ; Build ùêí
;;                                          (trace! (rec-S (term $term) (clf $clf) (cnt $cnt) (dir $dir))
;;                                          (if (is-expression $clf)
;;                                              (case $clf
;;                                                ((($g $h) ((ùêí (lc2cl (Œª $x $g) (+ 2 $cnt) ŒªL))
;;                                                           (lc2cl (Œª $x $h) (+ 2 $cnt) ŒªR)))
;;                                                 ($_ (empty))))
;;                                              $clf))
;;                                          ; Build ùêä
;;                                          (trace! (rec-K (term $term) (clf $clf) (cnt $cnt) (dir $dir))
;;                                          (ùêä $clf))))
;;                                    (empty)))
;;                               (($f $g) (trace! (rec-app (term $term) (cnt $cnt) (dir $dir))
;;                                        ((lc2cl $f (+ 1 $cnt) L) (lc2cl $g (+ 1 $cnt) R)))))))))))
;;        (trace! (bas-nch (term $term) (cnt $cnt) (dir $dir)) $term)))

;; NEXT: add tests on remaining individual combinators

;; Test lc2cl
!(assertEqual
  (lc2cl $f 0 C)
  $f)
!(assertEqual
  (lc2cl ($f $x) 0 C)
  ($f $x))
!(assertEqual
  (lc2cl ($f ($f $x)) 0 C)
  ($f ($f $x)))
!(assertEqual
  (lc2cl (Œª $x $x) 0 C)
  ùêà)
!(assertEqual
  (lc2cl (Œª $x (Œª $y $x)) 0 C)
  ùêä)
!(assertEqual
  (lc2cl (Œª $f (Œª $g (Œª $x (($f $x) ($g $x))))))
  ùêí)
!(assertEqual
  (lc2cl (Œª $x ($x $x)))
  ùêå)
!(assertEqual
  (lc2cl (Œª $x $f))
  (ùêä $f))
!(assertEqual
  (lc2cl (Œª $x ($f $g)))
  (ùêä ($f $g)))
;; NEXT: make sure that spontaneous reduction is not impoverishing the comparison.
!(assertEqual
  (lc2cl (Œª $f (Œª $x $x)))       ; 0
  ùêç)
!(assertEqual
  (lc2cl (Œª $n (Œª $f (Œª $x ($f (($n $f) $x)))))) ; Successor
  (ùêí ùêÅ))
!(assertEqual
  (lc2cl ((Œª $n (Œª $f (Œª $x ($f (($n $f) $x))))) ; Successor
          (Œª $f (Œª $x $x))))                     ; 0
  ((ùêí ùêÅ) ùêç))
!(assertEqual
  (lc2cl (Œª $f (Œª $x ($f $x))))            ; 1, as (Succ 0)
  ((ùêí ùêÅ) ùêç))
!(assertEqual
  (lc2cl (((Œª $m (Œª $n (Œª $f (Œª $x (($m $f) (($n $f) $x)))))) ; Plus
           (Œª $f (Œª $x $x)))                                  ; 0
          (Œª $f (Œª $x $x))))                                  ; 0
  (((ùêì (ùêí ùêÅ)) ùêç) ùêç))
!(assertEqual
  (lc2cl (((Œª $m (Œª $n (Œª $f (Œª $x (($m $f) (($n $f) $x)))))) ; Plus
           (Œª $f (Œª $x ($f $x))))                             ; 1
          (Œª $f (Œª $x ($f ($f $x))))))                        ; 2
  (((ùêì (ùêí ùêÅ)) ((ùêí ùêÅ) ùêç)) ((ùêí ùêÅ) ((ùêí ùêÅ) ùêç))))

;;;;;;;;;;;;;;;;;;;;;;;;;
;; MeTTa to Œª-calculus ;;
;;;;;;;;;;;;;;;;;;;;;;;;;

;; Convert metta to lambda calculus with De Bruijn indices.  It takes
;; in arguments
;;
;; 1. De Bruijn index to use for the next abstraction
;;
;; 2. MeTTa term.  Built-in operators such as let must be previously
;;    converted into LET to avoid spontaneous reduction.  NEXT: maybe
;;    we actually don't.
(: mt2lc (-> DeBruijn Atom Atom))
(= (mt2lc $idx $term)
   (case (get-metatype $term)
     ((Symbol $term)
      (Grounded $term)
      (Variable $term)
      (Expression (case $term
                    (;; Empty
                     (() ())
                     ;; LET
                     ((LET $x $y $f) (let* (($x $idx)
                                            ($ŒΩf (mt2lc (S' $idx) $f))
                                            ($ŒΩy (mt2lc $idx $y)))
                                       ((Œª $x $ŒΩf) $ŒΩy)))
                     ;; Application
                     (($f $x) ((mt2lc $idx $f) (mt2lc $idx $x)))
                     ;; Other
                     ($term $term)))))))

!(assertEqual
  (mt2lc Z' (LET $x (inc 1) (plus $x $x)))
  ((Œª Z' (plus Z' Z')) (inc 1)))

!(assertEqual
  (mt2lc Z'
         (LET $spleeter-output
              (snet.sound-spleeter.spleeter ((snet.sound-spleeter.MkInput "") $input))
              (LET $english-vocals (snet.sound-spleeter.Output.vocals $spleeter-output)
                   (LET $chinese-lyrics
                        (naint.machine-translation.Output.translation
                         (naint.machine-translation.translate
                          (((naint.machine-translation.MkInput "English") "Chinese")
                           (snet.speech-recognition.Text.text
                            (snet.speech-recognition.s2t
                             (snet.speech-recognition.MkAudio $english-vocals))))))
                        (LET $midi-notes (tomidi.MIDI.data (tomidi.MkAudio $english-vocals))
                             (LET $chinese-vocals
                                  (naint.midi2voice-zh.Answer.output_audio
                                   (naint.midi2voice-zh.singingZH
                                    (((naint.midi2voice-zh.MkQuery $chinese-lyrics)
                                      $midi-notes) 1.0)))
                                  (mixer.Audio.data
                                   (mixer.mix
                                    ((mixer.MkMultiAudio
                                      (snet.sound-spleeter.Output.accomp $spleeter-output))
                                     $chinese-vocals)))))))))
  ((Œª Z' ((Œª (S' Z') ((Œª (S' (S' Z')) ((Œª (S' (S' (S' Z'))) ((Œª (S' (S' (S' (S' Z')))) (mixer.Audio.data (mixer.mix ((mixer.MkMultiAudio (snet.sound-spleeter.Output.accomp Z')) (S' (S' (S' (S' Z')))))))) (naint.midi2voice-zh.Answer.output_audio (naint.midi2voice-zh.singingZH (((naint.midi2voice-zh.MkQuery (S' (S' Z'))) (S' (S' (S' Z')))) 1.0))))) (tomidi.MIDI.data (tomidi.MkAudio (S' Z'))))) (naint.machine-translation.Output.translation (naint.machine-translation.translate (((naint.machine-translation.MkInput "English") "Chinese") (snet.speech-recognition.Text.text (snet.speech-recognition.s2t (snet.speech-recognition.MkAudio (S' Z'))))))))) (snet.sound-spleeter.Output.vocals Z'))) (snet.sound-spleeter.spleeter ((snet.sound-spleeter.MkInput "") $input))))

;; We replace let by LET to avoid the program getting spontaneously
;; reduced, indeed the following
;;
;; !(let $spleeter-output
;;       (snet.sound-spleeter.spleeter ((snet.sound-spleeter.MkInput "") $input))
;;       (let $english-vocals (snet.sound-spleeter.Output.vocals $spleeter-output)
;;            (let $chinese-lyrics
;;                 (naint.machine-translation.Output.translation
;;                  (naint.machine-translation.translate
;;                   (((naint.machine-translation.MkInput "English") "Chinese")
;;                    (snet.speech-recognition.Text.text
;;                     (snet.speech-recognition.s2t
;;                      (snet.speech-recognition.MkAudio $english-vocals))))))
;;                 (let $midi-notes (tomidi.MIDI.data (tomidi.MkAudio $english-vocals))
;;                      (let $chinese-vocals
;;                           (naint.midi2voice-zh.Answer.output_audio
;;                            (naint.midi2voice-zh.singingZH
;;                             (((naint.midi2voice-zh.MkQuery $chinese-lyrics)
;;                               $midi-notes) 1.0)))
;;                           (mixer.Audio.data
;;                            (mixer.mix
;;                             ((mixer.MkMultiAudio
;;                               (snet.sound-spleeter.Output.accomp $spleeter-output))
;;                              $chinese-vocals))))))))
;;
;; results into
;;
;; (mixer.Audio.data
;;  (mixer.mix
;;   ((mixer.MkMultiAudio
;;     (snet.sound-spleeter.Output.accomp
;;      (snet.sound-spleeter.spleeter
;;       ((snet.sound-spleeter.MkInput "") $input))))
;;    (naint.midi2voice-zh.Answer.output_audio
;;     (naint.midi2voice-zh.singingZH
;;      (((naint.midi2voice-zh.MkQuery
;;         (naint.machine-translation.Output.translation
;;          (naint.machine-translation.translate
;;           (((naint.machine-translation.MkInput "English") "Chinese")
;;            (snet.speech-recognition.Text.text
;;             (snet.speech-recognition.s2t
;;              (snet.speech-recognition.MkAudio
;;               (snet.sound-spleeter.Output.vocals
;;                (snet.sound-spleeter.spleeter
;;                 ((snet.sound-spleeter.MkInput "") $input))))))))))
;;        (tomidi.MIDI.data
;;         (tomidi.MkAudio
;;          (snet.sound-spleeter.Output.vocals
;;           (snet.sound-spleeter.spleeter
;;            ((snet.sound-spleeter.MkInput "") $input)))))) 1.0))))))
;;
;; involving multiple calls of the same services.  In particular
;; snet.sound-spleeter.spleeter is called 3 times.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Definition of a chainer, Nat, plus and some proofs about the
;; existance of the parity properties of Nat such as Even and Odd.
;;
;; Implement a sigma type, take example from
;;
;; https://idris2.readthedocs.io/en/latest/tutorial/typesfuns.html#dependent-pairs
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;
;; Nat ;;
;;;;;;;;;

;; Define Nat
(: Nat Type)
(: Z Nat)
(: S (-> Nat Nat))

;; Define <=
(: <= (-> $a $a Bool))
(= (<= $x $y) (or (< $x $y) (== $x $y)))

;; Define cast functions between Nat and Number
(: fromNumber (-> Number Nat))
(= (fromNumber $n) (if (<= $n 0) Z (S (fromNumber (- $n 1)))))
(: fromNat (-> Nat Number))
(= (fromNat Z) 0)
(= (fromNat (S $k)) (+ 1 (fromNat $k)))

;;;;;;;;;;;;;;;;;;;;;
;; De Bruijn Index ;;
;;;;;;;;;;;;;;;;;;;;;

;; Define DeBruijn type
(: DeBruijn Type)

;; Define DeBruijn constructors
(: Z' DeBruijn)                        ; Zero
(: S' (-> DeBruijn DeBruijn))          ; Successor

;;;;;;;;;;
;; List ;;
;;;;;;;;;;

;; Declaration of List data type and constructors
(: List (-> $a Type))
(: Nil (List $a))
(: Cons (-> $a (List $a) (List $a)))

;;;;;;;;;;;;;;;;;;;;;
;; Match over list ;;
;;;;;;;;;;;;;;;;;;;;;

;; Similar to match but takes a list of terms instead of a space.
(: match' (-> (List Atom) $a $a $a))
(= (match' Nil $pattern $rewrite) (empty))
(= (match' (Cons $head $tail) $pattern $rewrite) (let $pattern $head $rewrite))
(= (match' (Cons $head $tail) $pattern $rewrite) (match' $tail $pattern $rewrite))

;; ;; Test match' on empty list
;; !(assertEqualToResult
;;   (match' Nil ($x $y) ($y $x))
;;   ())

;; ;; Test match' on singleton
;; !(assertEqual
;;   (match' (Cons (A B) Nil) ($x $y) ($y $x))
;;   (B A))

;; ;; Test match' on pair
;; !(assertEqualToResult
;;   (match' (Cons (A B) (Cons (C D) Nil)) ($x $y) ($y $x))
;;   ((B A)
;;    (D C)))

;;;;;;;;;;;;;;;;;;;;;;
;; Backward chainer ;;
;;;;;;;;;;;;;;;;;;;;;;

;; Curried Backward Chainer with lambda abstraction and dependent
;; types.  A lambda abstraction is represented by
;;
;; (Œª <INDEX> <BODY>)
;;
;; where <INDEX> is a De Bruijn index as define above, such as Z' or
;; (S' Z'), and <BODY> is a term possibly containing <INDEX>.  Note
;; that the use of De Bruijn index in lambda abstraction is somewhat
;; unconventional here.  It differs from what is described in
;; https://en.wikipedia.org/wiki/De_Bruijn_index in three ways:
;;
;; 1. The index is explicitely attached to a Œª by being its first
;;    argument.  For instance the lambda term Œªx.x, which would
;;    traditionally be represented by Œª1 using De Bruijn index, would
;;    be represented here by the MeTTa term (Œª Z' Z').
;;
;; 2. As seen in the example above the index here starts at 0,
;;    represented by Z', instead of 1.
;;
;; 3. The index increases as the lambda abstraction gets deeper.  For
;;    instance Œªx.Œªy.x, which would traditionally be represented by
;;    ŒªŒª2 using De Bruijn index, is represented here by the MeTTa term
;;    (Œª Z' (Œª (S' Z') Z').
;;
;; This differences are due to the way the proof abstraction recursive
;; step is defined in the bc, as well as the need for having non
;; overlapping pattern matching between the two recursive steps.
;; Specifically, if Œª had only one argument, then (Œª <BODY>) would
;; overlap with (<ABS> <ARG>).  Having Œª take 2 arguments instead of 1
;; has the disadvantage of making lambda abstraction not as compact.
;; On the flip side, the benefit is that the scope of an index is
;; easier to track.
;;
;; The arguments of the backward chainer are:
;;
;; * Knowledge base: pointer to a space containing axioms and rules in
;;   the format (: <NAME> <RULE>).  Note that rules are explicitely
;;   curried, meaning that a rule with two premises is represented by
;;
;;   (: <NAME> (-> <PREMISE1> (-> <PREMISE2> <CONCLUSION>)))
;;
;;   In addition, each premise must be an inline typing relationship,
;;   to represent dependent types.  It should be noted that such
;;   typing relationship must be provided even if the witness is not
;;   present in the rest of the definition.  For instance <PREMISE1>
;;   would have the format
;;
;;   (: <TERM1> <TYPE1>)
;;
;; * Environment: a list of typing relationship between De Bruijn
;;   index and type, such as
;;
;;   (Cons (: Z' String) (Cons (: (S' Z') Number) Nil))
;;
;; * De Bruijn Index: De Bruijn Index to use if a lambda abstraction
;;   is introduced.
;;
;; * Maximum depth: maximum depth of the generated proof tree.
;;
;; * Query: a metta term of the form (: <PROOF> <THEOREM>) where
;;   <PROOF> and <THEOREM> may contain free variables that may be
;;   filled by the backward chainer.  Note that for arguments of
;;   applications must be type annotated (unknowns types are of course
;;   allowed).  For instance the following query
;;
;;   (: (ModusPonens ab) $thrm)
;;
;;   would not work, instead one needs to provide
;;
;;   (: (ModusPonens (: ab $lemma)) $thrm)
;;
;; A result is the query with its variables grounded, fully or
;; partially.  If multiple results are possible, they are returned as
;; a superposition.
;;
;; As explained, the proof arguments must be type annotated.  Without
;; such type annotation, lambda abstraction sometimes leads to
;; incorrect results.  It is suspected to come from the fact that
;; otherwise the proof application recursive step loses bindings about
;; the premise.  Having annotated proof is however a good thing, to
;; display a proof tree and to have an indepth view into the proof.
;; In order to remove (resp. add) type annotation one can use
;; remove-type-annotation (resp. add-type).
(: bc (-> $a                            ; Knowledge base space
          $b                            ; Environment
          DeBruijn                      ; De Bruijn Index
          Nat                           ; Maximum depth
          $c                            ; Query
          $c))                          ; Result

;; Base cases

;; Match the knowledge base
(= (bc $kb $env $idx $_ (: $prf $thrm))
   (match $kb (: $prf $thrm) (: $prf $thrm)))
;; Match the environment
(= (bc $kb $env $idx $_ (: $prf $thrm))
   (match' $env (: $prf $thrm) (: $prf $thrm)))

;; Recursive steps

;; Proof application
(= (bc $kb $env $idx (S $k) (: ($prfabs (: $prfarg $prms)) $thrm))
   ;; (let () (println! (bc-app (env $env)
   ;;                           (idx $idx)
   ;;                           (depth (S $k))
   ;;                           (query (: ($prfabs (: $prfarg $prms)) $thrm))))
   (let* (((: $prfabs (-> (: $prfarg $prms) $thrm))
           (bc $kb $env $idx $k (: $prfabs (-> (: $prfarg $prms) $thrm))))
          ((: $prfarg $prms)
           (bc $kb $env $idx $k (: $prfarg $prms))))
     (: ($prfabs (: $prfarg $prms)) $thrm)))
;; Proof abstraction
(= (bc $kb $env $idx (S $k) (: (Œª $idx $prfbdy) (-> (: $idx $prms) $thrm)))
   ;; (let () (println! (bc-abs (env $env)
   ;;                           (idx $idx)
   ;;                           (depth (S $k))
   ;;                           (query (: (Œª $idx $prfbdy) (-> (: $idx $prms) $thrm)))))
   (let (: $prfbdy $thrm)
     (bc $kb (Cons (: $idx $prms) $env) (S' $idx) $k (: $prfbdy $thrm))
     (: (Œª $idx $prfbdy) (-> (: $idx $prms) $thrm))))

;;;;;;;;;;;;;;;;;;;;;;;;;
;; Knowledge/rule base ;;
;;;;;;;;;;;;;;;;;;;;;;;;;

!(bind! &kb (new-space))

;; The following code is translated into axioms and rules to handled
;; by the backward chainer.
;;
;; ;; Define Œ£ type (called DPair in Idris)
;; (: Œ£ (-> (: $a Type) (-> $a Type) Type))
;;
;; ;; Define DPair constructor
;; (: MkŒ£ (-> (: $p (-> $a Type)) (: $x $a) ($p $x) (Œ£ $a $p)))
;;
;; ;; Define the even property
;; (: Even (-> Nat Type))
;; (: MkEvenZ (Even Z))
;; (: MkEvenSS (-> (Even $k) (Even (S (S $k)))))
;;
;; ;; Define examples of even numbers (0 and 2)
;; (: (MkŒ£ Even Z MkEvenZ) (Œ£ Nat Even))
;; (: (MkŒ£ Even (S (S Z)) (MkEvenSS MkEvenZ)) (Œ£ Nat Even))
;; (: $prf (Œ£ Nat Even))
;;
;; ;; Define double function
;; (: double (-> Nat Nat))
;; (= (double Z) Z)
;; (= (double (S $k)) (S (S (double $k))))
;;
;; ;; Œ£ access functions
;; (: Œ£.val (-> (Œ£ $a $p) $a))
;; (= (Œ£.val (MkŒ£ $prop $val $prf)) $val)
;; (: Œ£.prf (-> (Œ£ $a $p) $p))
;; (= (Œ£.prf (MkŒ£ $prop $val $prf)) $prf)
;;
;; ;; Define double function, with the guaranty that the output is even
;; (: doubleŒ£ (-> Nat (Œ£ Nat Even)))
;; (= (doubleŒ£ Z) (MkŒ£ Even Z MkEvenZ))
;; (= (doubleŒ£ (S $k)) (MkŒ£ Even
;;                          (S (S (Œ£.val (doubleŒ£ $k))))
;;                          (MkEvenSS (Œ£.prf (doubleŒ£ $k)))))
;;
;; ;; For all x, (double x) is even
;; ;; ‚àÄx (Even (double x))
;; (: double-even-prf (-> (: $x Nat) (Even (double $x))))
;;
;; ;; Independent product type (i.e. conjunction)
;; (: ‚äó (-> Type Type Type))
;;
;; ;; Equality
;; (: === (-> $a $a Type))
;;
;; ;; ;; NEXT
;;
;; ;; ;; For all x, there exists k such that k = (double x) and k is even
;; ;; ;; ‚àÄx ‚àÉk k=(double x) ‚àß (Even k)
;; ;; (: double-Œ£-even-prf (-> ($x : Nat)
;; ;;                          (Œ£ Nat (Œª $k (‚äó (=== $k (double $x)) (Even $k))))))
;;
;; ;; (: double-Œ£-even-prf (-> ($x : Nat) (Œ£ Nat (EqualDoubleAndEven $x))))
;; ;; (: EqualDoubleAndEven (-> Nat (-> Nat Type)))
;; ;; (= ((EqualDoubleAndEven $x) $k) (‚äó (=== $k (double $x)) (Even $k)))
;; ;; ;; Or, alternatively
;; ;; ;; (= (EqualDoubleAndEven $x) (Œª $k (√ó (=== $k (double $x)) (Even $k))))

;; Define Nat, called ‚Ñï, with its constructors ùêô and ùêí to not have
;; MeTTa type checker interfer with the backward chainer
!(add-atom &kb (: ‚Ñï Type))
!(add-atom &kb (: ùêô ‚Ñï))
!(add-atom &kb (: ùêí (-> (: $x ‚Ñï) ‚Ñï)))

;; Define Even
!(add-atom &kb (: Even (-> (: $x ‚Ñï) Type)))
!(add-atom &kb (: MkEvenZ (Even ùêô)))
!(add-atom &kb (: MkEvenSS (-> (: $prf (Even $k))   ; Premise
                               (Even (ùêí (ùêí $k)))))) ; Conclusion

;; Define Œ£
!(add-atom &kb (: MkŒ£ (-> (: $p (-> (: $_ $a) Type)) ; Premise 1.  We
                                                     ; need to use (: $_ $a)
                                                     ; as opposed to just $a
                                                     ; to be fully consistent with
                                                     ; The (: PROOF PREMISE)
                                                     ; notation, till it becomes
                                                     ; optional.
                          (-> (: $x $a)              ; Premise 2
                              (-> (: $prf ($p $x))   ; Premise 3
                                  (Œ£ $a $p))))))     ; Conclusion

;; Equality is transitive
!(add-atom &kb (: Trans (-> (: $prf1 (=== $x $y))     ; Premise 1
                            (-> (: $prf2 (=== $y $z)) ; Premise 2
                                (=== $x $z)))))       ; Conclusion

;; Equality is symmetric
!(add-atom &kb (: Sym (-> (: $prf (=== $x $y)) ; Premise
                          (=== $y $x))))       ; Conclusion

;; Equality respects function application
!(add-atom &kb (: Cong (-> (: $f (-> (: $_ $a) $b))                 ; Premise 1
                           (-> (: $x $a)                            ; Premise 2
                               (-> (: $x' $a)                       ; Premise 3
                                   (-> (: $prf (=== $x $x'))        ; Premise 4
                                       (=== ($f $x) ($f $x')))))))) ; Conclusion

;; Rule of replacement
!(add-atom &kb (: Replace (-> (: $prf1 (=== $x $x')) ; Premise 1
                              (-> (: $prf2 $x)       ; Premise 2
                                  $x'))))            ; Conclusion

;; ;; Modus Ponens (application)
;; !(add-atom &kb (: MP (-> (: $f (-> (: $x $a) $b)) ; Premise 1
;;                          (-> (: $x $a)            ; Premise 2
;;                              $b))))               ; Conclusion

;; Define double
!(add-atom &kb (: double (-> (: $k ‚Ñï) ‚Ñï)))
!(add-atom &kb (: double_base (=== (double ùêô) ùêô)))
!(add-atom &kb (: double_rec (-> (: $k ‚Ñï)
                                 (=== (double (ùêí $k)) (ùêí (ùêí (double $k)))))))

;;;;;;;;;;;;;;;
;; Reduction ;;
;;;;;;;;;;;;;;;

;; Reduction rules to simplify proofs and reduce redundancy

;; TODO: these rules should be proven first.  Then they could
;; automatically be inserted.

;; ;; Involution of symmetry
;; (= (Sym (Sym $f)) $f)

;; ;; Identity
;; (= ((Œª $x $x) $y) $y)

;;;;;;;;;;;;;;;;;;;;;
;; Remove/add type ;;
;;;;;;;;;;;;;;;;;;;;;

;; Remove type annotations from a query.
;;
;; For instance
;;
;; (remove-type-annotation (: ((ModusPonens (: ab (‚Üí A B))) (: a A)) B))
;;
;; outputs
;;
;; ((ModusPonens ab) a)
(: remove-type-annotation (-> $a $a))
(= (remove-type-annotation $term)
   (case (get-metatype $term)
     ((Symbol $term)
      (Grounded $term)
      (Variable $term)
      (Expression (case $term
                    ;; Only covers up to trinary expression because
                    ;; for now the bc is not supposed to generate
                    ;; n-ary expression where n is greater 3.
                    ((() ())
                     (($x) ((remove-type-annotation $x)))
                     (($x $y) ((remove-type-annotation $x) (remove-type-annotation $y)))
                     (($x $y $z) (if (== $x :)
                                     (remove-type-annotation $y)
                                     ((remove-type-annotation $x)
                                      (remove-type-annotation $y)
                                      (remove-type-annotation $z))))
                     ($_ $_)))))))

;; Add type missing annotation to be compatible with bc query format.
;; Whatever is missing is only added as variables, not inferred, for
;; that one may use the bc.  Note that the first annotation must be
;; provided manually
;;
;; For instance
;;
;; (add-type-annotation ((ModusPonens ab) a))
;;
;; only outputs
;;
;; ((ModusPonens (: ab $t#1)) (: a $t#2))
;;
;; not
;;
;; (: ((ModusPonens (: ab $t#1)) (: a $t#2)) $t#3)
;;
;; That is because add-type-annotation can only detect application, that is a
;; term of the form (<ABS> <ARG>) to add the type annotation to <ARG>.
;;
;; NEXT: must keep track of the existing type to remain consistant.
(: add-type-annotation (-> $a $a))
(= (add-type-annotation $term)
   (case (get-metatype $term)
     ((Symbol $term)
      (Grounded $term)
      (Variable $term)
      (Expression (case $term
                    ((() ())
                     (($x) ($x))
                     (($x $y) (if (== $x S')
                                  ;; Treat De Bruijn index atomically
                                  $term
                                  ;; Add type annotation to argument of application
                                  (let $ŒΩx (add-type-annotation $x) ($ŒΩx (: (add-type-annotation $y) $t)))))
                     (($x $y $z) (if (== $x :)
                                     ;; Already a type annotation, recurse only on $y
                                     (: (add-type-annotation $y) $z)
                                     (if (== $x Œª)
                                         ;; Recurse only on body of lambda abstraction
                                         (Œª $y (add-type-annotation $z))
                                         $term)))
                     ($_ $_)))))))

;;;;;;;;;;;
;; Tests ;;
;;;;;;;;;;;

;; ;; Synthesize natural numbers
;; !(assertEqualToResult
;;   (bc &kb Nil Z' (fromNumber 1) (: $prf ‚Ñï))
;;   ((: (ùêí (: ùêô ‚Ñï)) ‚Ñï)
;;    (: (double (: ùêô ‚Ñï)) ‚Ñï)
;;    (: ùêô ‚Ñï)))

;; ;; Prove that 0 is even
;; !(assertEqualToResult
;;   (bc &kb Nil Z' (fromNumber 0) (: $prf (Even (fromNumber 0))))
;;   (: MkEvenZ (Even ùêô)))

;; ;; Prove that 2 is even
;; !(assertEqualToResult
;;   (bc &kb Nil Z' (fromNumber 1) (: $prf (Even (fromNumber 2))))
;;   (: (MkEvenSS (: MkEvenZ (Even ùêô))) (Even (ùêí (ùêí ùêô)))))

;; ;; Synthesize even numbers
;; ;; !(assertEqualToResult
;;   !(bc &kb Nil Z' (fromNumber 4) (: $prf (Œ£ ‚Ñï Even)))
;;   ;; ((: (((MkŒ£ (: Even (-> (: $_#81011 ‚Ñï) Type))) (: ùêô ‚Ñï)) (: MkEvenZ (Even ùêô))) (Œ£ ‚Ñï Even))
;;   ;;  )
;; ;; !(bc &kb (: $prf (Œ£ ‚Ñï Even)) (fromNumber 4))

;; ;; Synthesize unary functions over natural numbers, that is
;; ;; prove (-> (: $k ‚Ñï) ‚Ñï).
;; !(assertEqualToResult
;;   (bc &kb Nil Z' (fromNumber 1) (: $prf (-> (: $k ‚Ñï) ‚Ñï)))
;;   ((: (Œª Z' ùêô) (-> (: Z' ‚Ñï) ‚Ñï))
;;    (: (Œª Z' Z') (-> (: Z' ‚Ñï) ‚Ñï))
;;    (: ùêí (-> (: $k ‚Ñï) ‚Ñï))
;;    (: double (-> (: $k ‚Ñï) ‚Ñï))))

;; ;; Synthesize the identity function, that is prove (-> (: $x $a) $a)
;; ;; TODO: re-enable when we have assertContain
;; ;; !(assertEqualToResult
;; !(bc &kb Nil Z' (fromNumber 1) (: $prf (-> (: $x $a) $a)))
;;  ;; (: (Œª Z' Z') (-> (: Z' $a) $a))

;; ;; Synthesize the composition operator
;; !(bc &kb Nil Z' (fromNumber 3)
;;      (: $prf (-> (: $g (-> (: $y $b) $c)) (-> (: $f (-> (: $x $a) $b)) (-> (: $x $a) $c)))))

;; ;; Synthesize the flip operator, that is prove
;; ;;
;; ;; (-> (: $f (-> (: $x $a) (-> (: $y $b) $c)))
;; ;;     (-> (: $y $b) (-> (: $x $a) $c)))))
;; !(bc &kb Nil Z' (fromNumber 5)
;;      (: $prf (-> (: $f (-> (: $x $a) (-> (: $y $b) $c))) (-> (: $y $b) (-> (: $x $a) $c)))))

;; !(add-type-annotation (: ((Replace ((((Cong Even) ùêô) (double ùêô)) (Sym double_base))) MkEvenZ) (Even (double ùêô))))

;; ;; Prove that (double ùêô) is even.
;; ;;
;; ;; A possible proof of that is represented by the following proof tree:
;; ;;
;; ;;                               -(ùêô)      -----------------(double_base)
;; ;;                               ‚Ñï         (=== (double ùêô) ùêô)
;; ;; -----------------(Even) -(ùêô)  -(double) -----------------(Sym)
;; ;; (-> (: $_ ‚Ñï) Type)      ‚Ñï     ‚Ñï         (=== ùêô (double ùêô))
;; ;; ----------------------------------------------------------(Cong)  -------(MkEvenZ)
;; ;;                (=== (Even ùêô) (Even (double ùêô)))                   (Even ùêô)
;; ;;                ----------------------------------------------------------(Replace)
;; ;;                                       (Even (double ùêô))
;; ;;
;; ;; Or in MeTTa format:
;; ;;
;; ;; (: ((Replace ((((Cong Even) ùêô) (double ùêô)) (Sym double_base))) MkEvenZ) (Even (double ùêô)))
;; ;; !(bc &kb Nil Z' (fromNumber 6) (: $prf (Even (double ùêô))))
;; ;; !(bc &kb
;; ;;      Nil
;; ;;      Z'
;; ;;      (fromNumber 8)
;; ;;      (: ((Replace ((((Cong Even) ùêô) (double ùêô)) (Sym double_base))) MkEvenZ) (Even (double ùêô))))
!(bc &kb
     Nil
     Z'
     (fromNumber 6)
     (: ((Replace $subprf) (: MkEvenZ (Even ùêô)))
        (Even (double ùêô))))

;; NEXT: figure out why it doesn't work, or run the one above to
;; hopefully get the full solution

;; !(bc &kb
;;      Nil
;;      Z'
;;      (fromNumber 6)
;;      (: ((Replace
;;           (: ((((Cong
;;                  (: Even $t119078))
;;                 (: ùêô $t110284))
;;                (: (double (: ùêô $t144337)) $t98804))
;;               (: (Sym (: double_base $t166308)) $t83636)) $t63986))
;;          (: MkEvenZ $t43616))
;;         (Even (double ùêô))))

;; ;; Prove
;; ;;
;; ;; (-> (: Even (-> (: $_ ‚Ñï) Type))
;; ;;     (-> (: (double (ùêí $k)) ‚Ñï)
;; ;;         (-> (: (ùêí (ùêí (double $k))) ‚Ñï)
;; ;;             (-> (: $eq (=== (double (ùêí $k)) (ùêí (ùêí (double $k)))))
;; ;;                 (=== (Even (double (ùêí $k))) (Even (ùêí (ùêí (double $k)))))))))
;; ;;
;; ;; which should merely be Cong.
;; !(assertEqual
;;   (bc &kb Nil Z' (fromNumber 0)
;;       (: $prf (-> (: Even (-> (: $_ ‚Ñï) Type))
;;                   (-> (: (double (ùêí $k)) ‚Ñï)
;;                       (-> (: (ùêí (ùêí (double $k))) ‚Ñï)
;;                           (-> (: $eq (=== (double (ùêí $k)) (ùêí (ùêí (double $k)))))
;;                               (=== (Even (double (ùêí $k))) (Even (ùêí (ùêí (double $k)))))))))))
;;   (: Cong (-> (: Even (-> (: $_ ‚Ñï) Type))
;;               (-> (: (double (ùêí $k)) ‚Ñï)
;;                   (-> (: (ùêí (ùêí (double $k))) ‚Ñï)
;;                       (-> (: $eq (=== (double (ùêí $k)) (ùêí (ùêí (double $k)))))
;;                           (=== (Even (double (ùêí $k))) (Even (ùêí (ùêí (double $k)))))))))))

;; ;; Prove
;; ;;
;; ;; (-> (: (double (ùêí $k)) ‚Ñï)
;; ;;     (-> (: (ùêí (ùêí (double $k))) ‚Ñï)
;; ;;         (-> (: $eq (=== (double (ùêí $k)) (ùêí (ùêí (double $k)))))
;; ;;             (=== (Even (double (ùêí $k))) (Even (ùêí (ùêí (double $k))))))))
;; ;;
;; ;; which should be (Cong Even).
;; ;; TODO: re-enable after introducting assertAlphaEqual
;; ;; !(assertEqual
;;   (bc &kb Nil Z' (fromNumber 1)
;;       (: $prf (-> (: (double (ùêí $k)) ‚Ñï)
;;                   (-> (: (ùêí (ùêí (double $k))) ‚Ñï)
;;                       (-> (: $eq (=== (double (ùêí $k)) (ùêí (ùêí (double $k)))))
;;                           (=== (Even (double (ùêí $k))) (Even (ùêí (ùêí (double $k))))))))))
;;   ;; (: (Cong (: Even (-> (: $_ ‚Ñï) Type)))
;;   ;;    (-> (: (double (ùêí $k)) ‚Ñï)
;;   ;;        (-> (: (ùêí (ùêí (double $k))) ‚Ñï)
;;   ;;            (-> (: $eq (=== (double (ùêí $k)) (ùêí (ùêí (double $k)))))
;;   ;;                (=== (Even (double (ùêí $k))) (Even (ùêí (ùêí (double $k))))))))))

;; ;; Proof that
;; ;;
;; ;; (-> (: $k ‚Ñï)
;; ;;     (-> (: $eq (=== (double (ùêí $k)) (ùêí (ùêí (double $k)))))
;; ;;         (=== (Even (double (ùêí $k))) (Even (ùêí (ùêí (double $k)))))))
;; ;;
;; ;; which could be
;; ;;
;; ;; (Œª $k (((Cong Even) (double (ùêí $k))) (ùêí (ùêí (double $k)))))
;; !(bc &kb Nil Z' (fromNumber 4)
;;      (: $prf
;;         (-> (: $k ‚Ñï)
;;             (-> (: $eq (=== (double (ùêí $k)) (ùêí (ùêí (double $k)))))
;;                 (=== (Even (double (ùêí $k))) (Even (ùêí (ùêí (double $k)))))))))

;; ;; Prove
;; ;;
;; ;; (-> (: $k ‚Ñï)
;; ;;     (-> (: Even (-> (: $_ ‚Ñï) Type))
;; ;;         (-> (: (double (ùêí $k)) ‚Ñï)
;; ;;             (-> (: (ùêí (ùêí (double $k))) ‚Ñï)
;; ;;                 (-> (: $eq (=== (double (ùêí $k)) (ùêí (ùêí (double $k)))))
;; ;;                     (=== (Even (double (ùêí $k))) (Even (ùêí (ùêí (double $k))))))))))
;; ;;
;; ;; A possible proof could be
;; ;;
;; ;; (Œª $k Cong)
;; !(assertEqual
;;   (bc &kb Nil Z' (fromNumber 1)
;;       (: $prf
;;          (-> (: $k ‚Ñï)
;;              (-> (: Even (-> (: $_ ‚Ñï) Type))
;;                  (-> (: (double (ùêí $k)) ‚Ñï)
;;                      (-> (: (ùêí (ùêí (double $k))) ‚Ñï)
;;                          (-> (: $eq (=== (double (ùêí $k)) (ùêí (ùêí (double $k)))))
;;                              (=== (Even (double (ùêí $k))) (Even (ùêí (ùêí (double $k))))))))))))
;;   (: (Œª Z' Cong)
;;      (-> (: Z' ‚Ñï)
;;          (-> (: Even (-> (: $_ ‚Ñï) Type))
;;              (-> (: (double (ùêí Z')) ‚Ñï)
;;                  (-> (: (ùêí (ùêí (double Z'))) ‚Ñï)
;;                      (-> (: $eq (=== (double (ùêí Z')) (ùêí (ùêí (double Z')))))
;;                          (=== (Even (double (ùêí Z'))) (Even (ùêí (ùêí (double Z'))))))))))))

;; ;; NEXT

;; ;; ;; Prove that (-> (: $k ‚Ñï) (=== (Even (double (ùêí $k))) (Even (ùêí (ùêí (double $k))))))
;; ;; ;;
;; ;; ;; A possible proof tree would be
;; ;; ;;
;; ;; ;;
;; ;; ;; 
;; ;; ;; ----------------------------------------------------------------------------------------------
;; ;; ;; (-> (: $k ‚Ñï) (=== (Even (double (ùêí $k))) (Even (ùêí (ùêí (double $k))))))
;; ;; (bc &kb (: $prf (-> (: $k ‚Ñï) (=== (Even (double (ùêí $k))) (Even (ùêí (ùêí (double $k))))))) (fromNumber 7))

;; ;; ;; Prove that (=== (Even (ùêí (ùêí (double $k)))) (Even (double (ùêí $k))))
;; ;; ;;
;; ;; ;; (same as above but Sym)
;; ;; ;;
;; ;; (bc &kb (: $prf (=== (Even (ùêí (ùêí (double $k)))) (Even (double (ùêí $k))))) (fromNumber 5))
;; ;; (bc &kb (: $prf (-> (: $k ‚Ñï) (=== (Even (ùêí (ùêí (double $k)))) (Even (double (ùêí $k))))) (fromNumber 5)))

;; ;; Prove that if (double k) is even, then (double (ùêí k)) is even
;; ;;
;; ;; A possible proof of that is represented by the following proof tree:
;; ;;
;; ;; NEXT: test subproofs
;; ;;
;; ;;                                                                                                                                                                                         --------------------------------------------------------(double_rec)  ---------($k)
;; ;;                                                                                                                                                                                         (-> (: $k ‚Ñï) (=== (double (ùêí $k)) (ùêí (ùêí (double $k)))))             (: $k ‚Ñï)
;; ;;                                                                        -------------------(Even)  ----------------------(double (ùêí $k))  --------------------------(ùêí (ùêí (double $k)))  -------------------------------------------------------------------------------(ModusPonens)
;; ;;                                                                        (-> (: $_ ‚Ñï) Type)       (: (double (ùêí $k)) ‚Ñï)                (: (ùêí (ùêí (double $k))) ‚Ñï)                    (=== (double (ùêí $k)) (ùêí (ùêí (double $k))))
;; ;;                                                 -----------------($e)  ---------------------------------------------------------------------------------------------------------------------------------------------------------(Cong)
;; ;;                                                 (Even (double $k))                                           (=== (Even (double (ùêí $k))) (Even (ùêí (ùêí (double $k)))))
;; ;;                                                 -------------------------(MkEvenSS)                          ------------------------------------------------------(Sym)
;; ;;                                                 (Even (ùêí (ùêí (double $k))))                                   (=== (Even (ùêí (ùêí (double $k)))) (Even (double (ùêí $k))))
;; ;;                    -----------------($e)        -------------------------------------------------------------------------------------------------------------------(Replace)
;; ;;                    (Even (double $k))           (Even (double (ùêí $k)))
;; ;; --($k)             --------------------------------------------------(Œª)
;; ;; ‚Ñï                (-> (: $e (Even (double $k))) (Even (double (ùêí $k))
;; ;; ---------------------------------------------------------------------(Œª)
;; ;;  (-> (: $k ‚Ñï) (-> (: $e (Even (double $k))) (Even (double (ùêí $k)))
;; ;;
;; ;; Or in MeTTa format:
;; ;;
;; ;; (Œª (: $k ‚Ñï) (Œª (: $e (Even (double $k))) (Replace (MkEvenSS $e) (Sym (Cong Even (double (ùêí $k)) (ùêí (ùêí (double $k))) (ModusPonens double_rec $k))))))
;; ;;
;; ;; NEXT: is it possible to do better by using composition?  ANSWER: probably with composing double_rec, Trans, Sym and Cong

;; ;; ;; NEXT: this fails with the following error
;; ;; ;;
;; ;; ;; thread '<unnamed>' panicked at /home/nilg/Work/TrueAGI/hyperon-experimental/lib/src/atom/matcher.rs:199:14:
;; ;; ;; Unexpected state
;; ;; ;; note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
;; ;; ;; fatal runtime error: Rust panics must be rethrown
;; ;; ;; Aborted (core dumped)
;; ;; (bc &kb (: $prf (-> (: $k ‚Ñï) (-> (: $e (Even (double $k))) (Even (double (ùêí $k)))))) (fromNumber 8))

;; ;; ;; ;; Prove that for all x, (double x) is even
;; ;; ;; (bc &kb (: $prf (-> (: $x ‚Ñï) (Even (double $x)))) (fromNumber 3))

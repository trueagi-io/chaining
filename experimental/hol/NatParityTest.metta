;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Definition of a chainer, Nat, plus and some proofs about the
;; existance of the parity properties of Nat such as Even and Odd.
;;
;; Implement a sigma type, take example from
;;
;; https://idris2.readthedocs.io/en/latest/tutorial/typesfuns.html#dependent-pairs
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;
;; Nat ;;
;;;;;;;;;

;; Define Nat
(: Nat Type)
(: Z Nat)
(: S (-> Nat Nat))

;; Define <=
(: <= (-> $a $a Bool))
(= (<= $x $y) (or (< $x $y) (== $x $y)))

;; Define cast functions between Nat and Number
(: fromNumber (-> Number Nat))
(= (fromNumber $n) (if (<= $n 0) Z (S (fromNumber (- $n 1)))))
(: fromNat (-> Nat Number))
(= (fromNat Z) 0)
(= (fromNat (S $k)) (+ 1 (fromNat $k)))

;;;;;;;;;;;;;;;;;;;;;
;; De Bruijn Index ;;
;;;;;;;;;;;;;;;;;;;;;

;; Define DeBruijn type
(: DeBruijn Type)

;; Define DeBruijn constructors
(: z DeBruijn)                        ; Zero
(: s (-> DeBruijn DeBruijn))          ; Successor

;;;;;;;;;;
;; List ;;
;;;;;;;;;;

;; Declaration of List data type and constructors
(: List (-> $a Type))
(: Nil (List $a))
(: Cons (-> $a (List $a) (List $a)))

;;;;;;;;;;;;;;;;;;;;;
;; Match over list ;;
;;;;;;;;;;;;;;;;;;;;;

;; Similar to match but takes a list of terms instead of a space.
(: match' (-> (List Atom) $a $a $a))
(= (match' Nil $pattern $rewrite) (empty))
(= (match' (Cons $head $tail) $pattern $rewrite) (let $pattern $head $rewrite))
(= (match' (Cons $head $tail) $pattern $rewrite) (match' $tail $pattern $rewrite))

;; Test match' on empty list
!(assertEqualToResult
  (match' Nil ($x $y) ($y $x))
  ())

;; Test match' on singleton
!(assertEqual
  (match' (Cons (A B) Nil) ($x $y) ($y $x))
  (B A))

;; Test match' on pair
!(assertEqualToResult
  (match' (Cons (A B) (Cons (C D) Nil)) ($x $y) ($y $x))
  ((B A)
   (D C)))

;;;;;;;;;;;;;;;;;;;;;;
;; Backward chainer ;;
;;;;;;;;;;;;;;;;;;;;;;

;; Curried Backward Chainer with lambda abstraction and dependent
;; types.  A lambda abstraction is represented by
;;
;; (Œª <INDEX> <BODY>)
;;
;; where <INDEX> is a De Bruijn index as define above, such as z or
;; (s z), and <BODY> is a term possibly containing <INDEX>.  Note
;; that the use of De Bruijn index in lambda abstraction is somewhat
;; unconventional here.  It differs from what is described in
;; https://en.wikipedia.org/wiki/De_Bruijn_index in three ways:
;;
;; 1. The index is explicitely attached to a Œª by being its first
;;    argument.  For instance the lambda term Œªx.x, which would
;;    traditionally be represented by Œª1 using De Bruijn index, would
;;    be represented here by the MeTTa term (Œª z z).
;;
;; 2. As seen in the example above the index here starts at 0,
;;    represented by z, instead of 1.
;;
;; 3. The index increases as the lambda abstraction gets deeper.  For
;;    instance Œªx.Œªy.x, which would traditionally be represented by
;;    ŒªŒª2 using De Bruijn index, is represented here by the MeTTa term
;;    (Œª z (Œª (s z) z).
;;
;; This differences are due to the way the proof abstraction recursive
;; step is defined in the bc, as well as the need for having non
;; overlapping pattern matching between the two recursive steps.
;; Specifically, if Œª had only one argument, then (Œª <BODY>) would
;; overlap with (<ABS> <ARG>).  Having Œª take 2 arguments instead of 1
;; has the disadvantage of making lambda abstraction not as compact.
;; On the flip side, the benefit is that the scope of an index is
;; easier to track.
;;
;; The arguments of the backward chainer are:
;;
;; * Knowledge base: pointer to a space containing axioms and rules in
;;   the format (: <NAME> <RULE>).  Note that rules are explicitely
;;   curried, meaning that a rule with two premises is represented by
;;
;;   (: <NAME> (-> <PREMISE1> (-> <PREMISE2> <CONCLUSION>)))
;;
;;   In addition, each premise must be an inline typing relationship,
;;   to represent dependent types.  It should be noted that such
;;   typing relationship must be provided even if the witness is not
;;   present in the rest of the definition.  For instance <PREMISE1>
;;   would have the format
;;
;;   (: <TERM1> <TYPE1>)
;;
;; * Environment: a list of typing relationship between De Bruijn
;;   index and type, such as
;;
;;   (Cons (: z String) (Cons (: (s z) Number) Nil))
;;
;; * De Bruijn Index: De Bruijn Index to use if a lambda abstraction
;;   is introduced.
;;
;; * Maximum depth: maximum depth of the generated proof tree.
;;
;; * Query: a metta term of the form (: <PROOF> <THEOREM>) where
;;   <PROOF> and <THEOREM> may contain free variables that may be
;;   filled by the backward chainer.  Note that for arguments of
;;   applications must be type annotated (unknowns types are of course
;;   allowed).  For instance the following query
;;
;;   (: (ModusPonens ab) $thrm)
;;
;;   would not work, instead one needs to provide
;;
;;   (: (ModusPonens (: ab $lemma)) $thrm)
;;
;; A result is the query with its variables grounded, fully or
;; partially.  If multiple results are possible, they are returned as
;; a superposition.
;;
;; As explained, the proof arguments must be type annotated.  Without
;; such type annotation, lambda abstraction sometimes leads to
;; incorrect results.  It is suspected to come from the fact that
;; otherwise the proof application recursive step loses bindings about
;; the premise.  Having annotated proof is however a good thing, to
;; display a proof tree and to have an indepth view into the proof.
;; In order to remove (resp. add) type annotation one can use
;; remove-type-annotation (resp. add-type).
(: bc (-> $a                            ; Knowledge base space
          $b                            ; Environment
          DeBruijn                      ; De Bruijn Index
          Nat                           ; Maximum depth
          $c                            ; Query
          $c))                          ; Result

;; Base cases

;; Match the knowledge base
(= (bc $kb $env $idx $_ (: $prf $thrm))
   (match $kb (: $prf $thrm) (: $prf $thrm)))
;; Match the environment
(= (bc $kb $env $idx $_ (: $prf $thrm))
   (match' $env (: $prf $thrm) (: $prf $thrm)))

;; Recursive steps

;; Proof application
(= (bc $kb $env $idx (S $k) (: ($prfabs (: $prfarg $prms)) $thrm))
   (let* (((: $prfabs (-> (: $prfarg $prms) $thrm))
           (bc $kb $env $idx $k (: $prfabs (-> (: $prfarg $prms) $thrm))))
          ((: $prfarg $prms)
           (bc $kb $env $idx $k (: $prfarg $prms))))
     (: ($prfabs (: $prfarg $prms)) $thrm)))

;; TODO: this is necessary for structural induction but makes
;; everything extremely slow.
;;
;; Proof abstraction
(= (bc $kb $env $idx (S $k) (: (Œª $idx $prfbdy) (-> (: $idx $prms) $thrm)))
   (let (: $prfbdy $thrm)
     (bc $kb (Cons (: $idx $prms) $env) (s $idx) $k (: $prfbdy $thrm))
     (: (Œª $idx $prfbdy) (-> (: $idx $prms) $thrm))))

;;;;;;;;;;;;;;;;;;;;;;;;;
;; Knowledge/rule base ;;
;;;;;;;;;;;;;;;;;;;;;;;;;

!(bind! &kb (new-space))

;; The following code is translated into axioms and rules to handled
;; by the backward chainer.
;;
;; ;; Define Œ£ type (called DPair in Idris)
;; (: Œ£ (-> (: $a Type) (-> $a Type) Type))
;;
;; ;; Define DPair constructor
;; (: MkŒ£ (-> (: $p (-> $a Type)) (: $x $a) ($p $x) (Œ£ $a $p)))
;;
;; ;; Define the even property
;; (: Even (-> Nat Type))
;; (: MkEvenZ (Even Z))
;; (: MkEvenSS (-> (Even $k) (Even (S (S $k)))))
;;
;; ;; Define examples of even numbers (0 and 2)
;; (: (MkŒ£ Even Z MkEvenZ) (Œ£ Nat Even))
;; (: (MkŒ£ Even (S (S Z)) (MkEvenSS MkEvenZ)) (Œ£ Nat Even))
;; (: $prf (Œ£ Nat Even))
;;
;; ;; Define double function
;; (: double (-> Nat Nat))
;; (= (double Z) Z)
;; (= (double (S $k)) (S (S (double $k))))
;;
;; ;; Œ£ access functions
;; (: Œ£.val (-> (Œ£ $a $p) $a))
;; (= (Œ£.val (MkŒ£ $prop $val $prf)) $val)
;; (: Œ£.prf (-> (Œ£ $a $p) $p))
;; (= (Œ£.prf (MkŒ£ $prop $val $prf)) $prf)
;;
;; ;; Define double function, with the guaranty that the output is even
;; (: doubleŒ£ (-> Nat (Œ£ Nat Even)))
;; (= (doubleŒ£ Z) (MkŒ£ Even Z MkEvenZ))
;; (= (doubleŒ£ (S $k)) (MkŒ£ Even
;;                          (S (S (Œ£.val (doubleŒ£ $k))))
;;                          (MkEvenSS (Œ£.prf (doubleŒ£ $k)))))
;;
;; ;; For all x, (double x) is even
;; ;; ‚àÄx (Even (double x))
;; (: double-even-prf (-> (: $x Nat) (Even (double $x))))
;;
;; ;; Independent product type (i.e. conjunction)
;; (: ‚äó (-> Type Type Type))
;;
;; ;; Equality
;; (: === (-> $a $a Type))
;;
;; ;; ;; TODO
;;
;; ;; ;; For all x, there exists k such that k = (double x) and k is even
;; ;; ;; ‚àÄx ‚àÉk k=(double x) ‚àß (Even k)
;; ;; (: double-Œ£-even-prf (-> ($x : Nat)
;; ;;                          (Œ£ Nat (Œª $k (‚äó (=== $k (double $x)) (Even $k))))))
;;
;; ;; (: double-Œ£-even-prf (-> ($x : Nat) (Œ£ Nat (EqualDoubleAndEven $x))))
;; ;; (: EqualDoubleAndEven (-> Nat (-> Nat Type)))
;; ;; (= ((EqualDoubleAndEven $x) $k) (‚äó (=== $k (double $x)) (Even $k)))
;; ;; ;; Or, alternatively
;; ;; ;; (= (EqualDoubleAndEven $x) (Œª $k (√ó (=== $k (double $x)) (Even $k))))

;; Define Nat, called ‚Ñï, with its constructors ùêô and ùêí to not have
;; MeTTa type checker interfere with the backward chainer
!(add-atom &kb (: ‚Ñï Type))
!(add-atom &kb (: ùêô ‚Ñï))
!(add-atom &kb (: ùêí (-> (: $x ‚Ñï) ‚Ñï)))

;; Define Even
!(add-atom &kb (: Even (-> (: $x ‚Ñï) Type)))
!(add-atom &kb (: MkEvenZ (Even ùêô)))
!(add-atom &kb (: MkEvenSS (-> (: $prf (Even $k))               ; Premise
                               (Even (ùêí (: (ùêí (: $k ‚Ñï)) ‚Ñï)))))) ; Conclusion

;; Define Œ£
!(add-atom &kb (: MkŒ£ (-> (: $p (-> (: $_ $a) Type)) ; Premise 1.  We
                                                     ; need to use (: $_ $a)
                                                     ; as opposed to just $a
                                                     ; to be fully consistent with
                                                     ; The (: PROOF PREMISE)
                                                     ; notation, till it becomes
                                                     ; optional.
                          (-> (: $x $a)              ; Premise 2
                              (-> (: $prf ($p $x))   ; Premise 3
                                  (Œ£ $a $p))))))     ; Conclusion

;; Equality is transitive
!(add-atom &kb (: Trans (-> (: $prf1 (=== $x $y))     ; Premise 1
                            (-> (: $prf2 (=== $y $z)) ; Premise 2
                                (=== $x $z)))))       ; Conclusion

;; Equality is symmetric
!(add-atom &kb (: Sym (-> (: $prf (=== $x $y)) ; Premise
                          (=== $y $x))))       ; Conclusion

;; Equality respects function application
!(add-atom &kb (: Cong (-> (: $f (-> (: $_ $a) $b))                 ; Premise 1
                           (-> (: $x $a)                            ; Premise 2
                               (-> (: $x' $a)                       ; Premise 3
                                   (-> (: $prf (=== $x $x'))        ; Premise 4
                                       (=== ($f $x) ($f $x')))))))) ; Conclusion

;; Rule of replacement
!(add-atom &kb (: Replace (-> (: $prf1 (=== $x $x')) ; Premise 1
                              (-> (: $prf2 $x)       ; Premise 2
                                  $x'))))            ; Conclusion

;; Define double
!(add-atom &kb (: double (-> (: $k ‚Ñï) ‚Ñï)))
!(add-atom &kb (: double_base (=== (double (: ùêô ‚Ñï)) ùêô)))
!(add-atom &kb (: double_rec (-> (: $k ‚Ñï)
                                 (=== (double (: (ùêí (: $k ‚Ñï)) ‚Ñï)) (ùêí (: (ùêí (: (double (: $k ‚Ñï)) ‚Ñï)) ‚Ñï))))))

;;;;;;;;;;;;;;;
;; Reduction ;;
;;;;;;;;;;;;;;;

;; Reduction rules to simplify proofs and reduce redundancy

;; TODO: these rules should be proven first.  Then they could
;; automatically be inserted.

;; ;; Involution of symmetry
;; ;; (= (Sym (Sym $f)) $f)
;; (= (: (Sym (: (Sym (: $x $a)) $b)) $c) (: $x $a))

;; ;; Involution of Trans and Sym
;; ;; (= ((Trans $x) (Sym $x)) $x)
;; ;; (= ((Trans (Sym $x)) $x) $x)
;; (= (: ((Trans (: $x $a)) (: (Sym (: $x $a)) $b)) $c) (: $x $a))
;; (= (: ((Trans (: (Sym (: $x $a)) $b)) (: $x $a)) $c) (: $x $a))

;; Identity
(= ((Œª $x $x) $y) $y)

;; ;; Test reduction of (Sym (Sym (Sym double_base)))
;; !(assertEqual
;;   (: (Sym
;;       (: (Sym
;;           (: (Sym
;;               (: double_base (=== (double (: ùêô ‚Ñï)) ùêô)))
;;              (=== ùêô (double (: ùêô ‚Ñï)))))
;;          (=== (double (: ùêô ‚Ñï)) ùêô)))
;;      (=== ùêô (double (: ùêô ‚Ñï))))
;;   (: (Sym (: double_base (=== (double (: ùêô ‚Ñï)) ùêô))) (=== ùêô (double (: ùêô ‚Ñï)))))

;; ;; Test reduction of ((Œª z z) $x)
;; !(assertEqual
;;   ((Œª z z) $x)
;;   $x)

;;;;;;;;;;;;;;;;;;;;;
;; Remove/add type ;;
;;;;;;;;;;;;;;;;;;;;;

;; Remove type annotations from a query.
;;
;; For instance
;;
;; (remove-type-annotation (: ((ModusPonens (: ab (‚Üí A B))) (: a A)) B))
;;
;; outputs
;;
;; ((ModusPonens ab) a)
(: remove-type-annotation (-> $a $a))
(= (remove-type-annotation $term)
   (case (get-metatype $term)
     ((Symbol $term)
      (Grounded $term)
      (Variable $term)
      (Expression (case $term
                    ;; Only covers up to trinary expression because
                    ;; for now the bc is not supposed to generate
                    ;; n-ary expression where n is greater 3.
                    ((() ())
                     (($x) ((remove-type-annotation $x)))
                     (($x $y) ((remove-type-annotation $x) (remove-type-annotation $y)))
                     (($x $y $z) (if (== $x :)
                                     (remove-type-annotation $y)
                                     ((remove-type-annotation $x)
                                      (remove-type-annotation $y)
                                      (remove-type-annotation $z))))
                     ($_ $_)))))))

;; Add type missing annotation to be compatible with bc query format.
;; Whatever is missing is only added as variables, not inferred, for
;; that one may use the bc.  Note that the first annotation must be
;; provided manually
;;
;; For instance
;;
;; (add-type-annotation ((ModusPonens ab) a))
;;
;; only outputs
;;
;; ((ModusPonens (: ab $t#1)) (: a $t#2))
;;
;; not
;;
;; (: ((ModusPonens (: ab $t#1)) (: a $t#2)) $t#3)
;;
;; That is because add-type-annotation can only detect application, that is a
;; term of the form (<ABS> <ARG>) to add the type annotation to <ARG>.
;;
;; TODO: must keep track of the existing type to remain consistant.
(: add-type-annotation (-> $a $a))
(= (add-type-annotation $term)
   (case (get-metatype $term)
     ((Symbol $term)
      (Grounded $term)
      (Variable $term)
      (Expression (case $term
                    ((() ())
                     (($x) ($x))
                     (($x $y) (if (== $x s)
                                  ;; Treat De Bruijn index atomically
                                  $term
                                  ;; Add type annotation to argument of application
                                  (let $ŒΩx (add-type-annotation $x) ($ŒΩx (: (add-type-annotation $y) $t)))))
                     (($x $y $z) (if (== $x :)
                                     ;; Already a type annotation, recurse only on $y
                                     (: (add-type-annotation $y) $z)
                                     (if (== $x Œª)
                                         ;; Recurse only on body of lambda abstraction
                                         (Œª $y (add-type-annotation $z))
                                         $term)))
                     ($_ $_)))))))

;;;;;;;;;;;
;; Tests ;;
;;;;;;;;;;;

;; ;; Synthesize natural numbers
;; !(assertEqualToResult
;;   (bc &kb Nil z (fromNumber 1) (: $prf ‚Ñï))
;;   ((: (ùêí (: ùêô ‚Ñï)) ‚Ñï)
;;    (: (double (: ùêô ‚Ñï)) ‚Ñï)
;;    (: ùêô ‚Ñï)))

;; ;; Prove that 0 is even
;; !(assertEqual
;;   (bc &kb Nil z (fromNumber 0) (: $prf (Even ùêô)))
;;   (: MkEvenZ (Even ùêô)))

;; ;; Prove that 2 is even
;; !(assertEqual
;;   (bc &kb Nil z (fromNumber 1) (: $prf (Even (ùêí (ùêí ùêô)))))
;;   (: (MkEvenSS (: MkEvenZ (Even ùêô))) (Even (ùêí (ùêí ùêô)))))

;; ;; Synthesize even numbers
;; TODO: needs alpha equivalence
;; !(assertEqual
;;   (bc &kb Nil z (fromNumber 4) (: $prf (Œ£ ‚Ñï Even)))
;;   (: (((MkŒ£ (: Even (-> (: $_13500890 ‚Ñï) Type))) (: ùêô ‚Ñï)) (: MkEvenZ (Even ùêô))) (Œ£ ‚Ñï Even)))

;; ;; Synthesize unary functions over natural numbers, that is
;; ;; prove (-> (: $k ‚Ñï) ‚Ñï).
;; !(assertEqualToResult
;;   (bc &kb Nil z (fromNumber 1) (: $prf (-> (: $k ‚Ñï) ‚Ñï)))
;;   ((: (Œª z ùêô) (-> (: z ‚Ñï) ‚Ñï))
;;    (: (Œª z z) (-> (: z ‚Ñï) ‚Ñï))
;;    (: ùêí (-> (: $k ‚Ñï) ‚Ñï))
;;    (: double (-> (: $k ‚Ñï) ‚Ñï))))

;; ;; Synthesize the identity function, that is prove (-> (: $x $a) $a)
;; ;; TODO: re-enable when we have assertContain
;; ;; !(assertEqualToResult
;; !(bc &kb Nil z (fromNumber 1) (: $prf (-> (: $x $a) $a)))
;;  ;; (: (Œª z z) (-> (: z $a) $a))

;; ;; Synthesize the composition operator
;; !(bc &kb Nil z (fromNumber 4)
;;      (: $prf (-> (: $g (-> (: $y $b) $c))
;;                  (-> (: $f (-> (: $x $a) $b))
;;                      (-> (: $x $a) $c)))))

;; ;; Synthesize the flip operator, that is prove
;; ;;
;; ;; (-> (: $f (-> (: $x $a) (-> (: $y $b) $c)))
;; ;;     (-> (: $y $b) (-> (: $x $a) $c)))))
;; !(bc &kb Nil z (fromNumber 5)
;;      (: $prf (-> (: $f (-> (: $x $a) (-> (: $y $b) $c)))
;;                  (-> (: $y $b) (-> (: $x $a) $c)))))

;; ;; Prove that Even is a type constructor that takes a natural
;; ;;
;; ;; A possible proof of that is represented by the following proof tree:
;; ;;
;; ;; -----------------(Even)
;; ;; (-> (: $_ ‚Ñï) Type)
;; ;;
;; !(assertEqual
;;   (bc &kb Nil z (fromNumber 0) (: $prf (-> (: $_ ‚Ñï) Type)))
;;   (: Even (-> (: $_ ‚Ñï) Type)))

;; ;; Verify that ùêô is a natural
;; ;;
;; ;; A possible proof of that is represented by the following proof tree:
;; ;;
;; ;; -(ùêô)
;; ;; ‚Ñï
;; ;;
;; !(assertEqual
;;   (bc &kb Nil z (fromNumber 0) (: ùêô ‚Ñï))
;;   (: ùêô ‚Ñï))

;; ;; Verify that (double ùêô) is a natural.
;; ;;
;; ;; A possible proof of that is represented by the following proof tree:
;; ;;
;; ;;  -(ùêô)
;; ;;  ‚Ñï
;; ;;  -(double)
;; ;;  ‚Ñï
;; ;;
;; !(assertEqual
;;   (bc &kb Nil z (fromNumber 1) (: (double (: ùêô ‚Ñï)) ‚Ñï))
;;   (: (double (: ùêô ‚Ñï)) ‚Ñï))

;; ;; Prove that ùêô = (double ùêô).
;; ;;
;; ;; A possible proof of that is represented by the following proof tree:
;; ;;
;; ;; -----------------(double_base)
;; ;; (=== (double ùêô) ùêô)
;; ;; -----------------(Sym)
;; ;; (=== ùêô (double ùêô))
;; ;;
;; ;; Or in MeTTa format:
;; ;;
;; ;; (: (Sym double_base) (=== ùêô (double ùêô)))
;; !(assertEqual
;;   (bc &kb Nil z (fromNumber 1) (: $prf (=== ùêô (double (: ùêô ‚Ñï)))))
;;   (: (Sym (: double_base (=== (double (: ùêô ‚Ñï)) ùêô)))
;;      (=== ùêô (double (: ùêô ‚Ñï)))))

;; ;; Like above with depth of 3.  Used to test reduction rules.
;; ;; !(assertEqual
;;   !(bc &kb Nil z (fromNumber 3) (: $prf (=== ùêô (double (: ùêô ‚Ñï)))))
;;   ;; (: (Sym (: double_base (=== (double (: ùêô ‚Ñï)) ùêô)))
;;   ;;    (=== ùêô (double (: ùêô ‚Ñï)))))

;; ;; Infer the theorem that (Cong Even) proves.
;; ;;
;; ;; A possible proof of that is represented by the following proof tree:
;; ;;
;; ;; -----------------(Even)
;; ;; (-> (: $_ ‚Ñï) Type)
;; ;; ---------------------------------------------------------------------------------(Cong)
;; ;; (-> (: $x ‚Ñï) (-> (: $x' ‚Ñï) (-> (: $prf (=== $x $x')) (=== (Even $x) (Even $x')))))
;; ;;
;; ;; TODO: use assertEqual once we support alpha-equivalence
;; ;; !(assertEqual
;; !(bc &kb Nil z (fromNumber 1) (: (Cong (: Even $t)) $thrm))
;;   ;; (: (Cong (: Even (-> (: $_ ‚Ñï) Type)))
;;   ;;    (-> (: $x ‚Ñï)
;;   ;;        (-> (: $x' ‚Ñï)
;;   ;;            (-> (: $prf (=== $x $x'))
;;   ;;                (=== (Even $x) (Even $x'))))))

;; ;; Infer the theorem that (Cong Even ùêô) proves.
;; ;;
;; ;; A possible proof of that is represented by the following proof tree:
;; ;;
;; ;; -----------------(Even) -(ùêô)
;; ;; (-> (: $_ ‚Ñï) Type)      ‚Ñï
;; ;; -------------------------------------------------------------------(Cong)
;; ;; (-> (: $x' ‚Ñï) (-> (: $prf (=== ùêô $x')) (=== (Even ùêô) (Even $x'))))
;; ;;
;; ;; TODO: use assertEqual once we support alpha-equivalence
;; ;; !(assertEqual
;; !(bc &kb Nil z (fromNumber 2) (: ((Cong (: Even $t1)) (: ùêô $t2)) $thrm))
;;   ;; (: ((Cong (: Even (-> (: $_ ‚Ñï) Type))) (: ùêô ‚Ñï))
;;   ;;    (-> (: $x' ‚Ñï)
;;   ;;        (-> (: $prf (=== ùêô $x'))
;;   ;;            (=== (Even ùêô) (Even $x')))))

;; ;; Infer the theorem that (Cong Even ùêô (double ùêô)) proves.
;; ;;
;; ;; A possible proof of that is represented by the following proof tree:
;; ;;
;; ;;                              -(ùêô)
;; ;;                              ‚Ñï
;; ;; -----------------(Even) -(ùêô) -(double)
;; ;; (-> (: $_ ‚Ñï) Type)      ‚Ñï    ‚Ñï
;; ;; -----------------------------------------------------------------(Cong)
;; ;; (-> (: $prf (=== ùêô (double ùêô))) (=== (Even ùêô) (Even (double ùêô))))
;; ;;
;; ;; TODO: use assertEqual once we support alpha-equivalence
;; ;; !(assertEqual
;; !(bc &kb
;;      Nil
;;      z
;;      (fromNumber 3)
;;      (: (((Cong (: Even $t1)) (: ùêô $t2)) (: (double (: ùêô $t3)) $t4)) $thrm))
;;   ;; (: (((Cong (: Even (-> (: $_ ‚Ñï) Type))) (: ùêô ‚Ñï)) (: (double (: ùêô ‚Ñï)) ‚Ñï))
;;   ;;    (-> (: $prf (=== ùêô (double (: ùêô ‚Ñï))))
;;   ;;        (=== (Even ùêô) (Even (double (: ùêô ‚Ñï))))))

;; ;; Find proof of (-> (: $hyp (=== ùêô (double ùêô))) (=== (Even ùêô) (Even (double ùêô))))
;; ;;
;; ;; A possible proof of that is represented by the following proof tree:
;; ;;
;; ;;                              -(ùêô)
;; ;;                              ‚Ñï
;; ;; -----------------(Even) -(ùêô) -(double)
;; ;; (-> (: $_ ‚Ñï) Type)      ‚Ñï    ‚Ñï
;; ;; -----------------------------------------------------------------(Cong)
;; ;; (-> (: $hyp (=== ùêô (double ùêô))) (=== (Even ùêô) (Even (double ùêô))))
;; ;;
;; ;; TODO: use assertEqual once we support alpha-equivalence
;; ;; !(assertEqual
;;   !(bc &kb
;;       Nil
;;       z
;;       (fromNumber 3)
;;       (: $prf (-> (: $hyp (=== ùêô (double (: ùêô ‚Ñï)))) (=== (Even ùêô) (Even (double (: ùêô ‚Ñï)))))))
;;   ;; (: (((Cong (: Even (-> (: $_ ‚Ñï) Type))) (: ùêô ‚Ñï)) (: (double (: ùêô ‚Ñï)) ‚Ñï))
;;   ;;    (-> (: $hyp (=== ùêô (double (: ùêô ‚Ñï))))
;;   ;;        (=== (Even ùêô) (Even (double (: ùêô ‚Ñï)))))))

;; ;; Infer the theorem that (Cong Even ùêô (double ùêô) (Sym double_base)) proves.
;; ;;
;; ;; A possible proof of that is represented by the following proof tree:
;; ;;
;; ;;                               -(ùêô)      -----------------(double_base)
;; ;;                               ‚Ñï         (=== (double ùêô) ùêô)
;; ;; -----------------(Even) -(ùêô)  -(double) -----------------(Sym)
;; ;; (-> (: $_ ‚Ñï) Type)      ‚Ñï     ‚Ñï         (=== ùêô (double ùêô))
;; ;; ----------------------------------------------------------(Cong)
;; ;;                (=== (Even ùêô) (Even (double ùêô)))
;; ;;
;; ;; TODO: use assertEqual once we support alpha-equivalence
;; ;; !(assertEqual
;; !(bc &kb
;;      Nil
;;      z
;;      (fromNumber 4)
;;      (: ((((Cong
;;             (: Even $t1))
;;            (: ùêô $t2))
;;           (: (double (: ùêô $t3)) $t4))
;;          (: (Sym (: double_base $t5)) $t6))
;;         $thrm))
;;   ;; (: ((((Cong
;;   ;;        (: Even (-> (: $_ ‚Ñï) Type)))
;;   ;;       (: ùêô ‚Ñï))
;;   ;;      (: (double (: ùêô ‚Ñï)) ‚Ñï))
;;   ;;     (: (Sym (: double_base (=== (double (: ùêô ‚Ñï)) ùêô))) (=== ùêô (double (: ùêô ‚Ñï)))))
;;   ;;    (=== (Even ùêô) (Even (double (: ùêô ‚Ñï)))))

;; ;; Find the proof of (=== (Even ùêô) (Even (double (: ùêô ‚Ñï)))) starting
;; ;; by Cong.
;; ;;
;; ;; A possible proof of that is represented by the following proof tree:
;; ;;
;; ;;                               -(ùêô)      -----------------(double_base)
;; ;;                               ‚Ñï         (=== (double ùêô) ùêô)
;; ;; -----------------(Even) -(ùêô)  -(double) -----------------(Sym)
;; ;; (-> (: $_ ‚Ñï) Type)      ‚Ñï     ‚Ñï         (=== ùêô (double ùêô))
;; ;; ----------------------------------------------------------(Cong)
;; ;;                (=== (Even ùêô) (Even (double ùêô)))
;; ;;
;; ;; TODO: use assertEqual once we support alpha-equivalence
;; ;; !(assertEqual
;; !(bc &kb
;;      Nil
;;      z
;;      (fromNumber 4)
;;      (: ((((Cong
;;             $prf1)
;;            $prf2)
;;           $prf3)
;;          $prf4)
;;         (=== (Even ùêô) (Even (double (: ùêô ‚Ñï))))))
;;   ;; (: ((((Cong
;;   ;;        (: Even (-> (: $_ ‚Ñï) Type)))
;;   ;;       (: ùêô ‚Ñï))
;;   ;;      (: (double (: ùêô ‚Ñï)) ‚Ñï))
;;   ;;     (: (Sym (: double_base (=== (double (: ùêô ‚Ñï)) ùêô))) (=== ùêô (double (: ùêô ‚Ñï)))))
;;   ;;    (=== (Even ùêô) (Even (double (: ùêô ‚Ñï)))))

;; ;; Find the proof of (=== (Even ùêô) (Even (double (: ùêô ‚Ñï))))
;; ;;
;; ;; A possible proof of that is represented by the following proof tree:
;; ;;
;; ;;                               -(ùêô)      -----------------(double_base)
;; ;;                               ‚Ñï         (=== (double ùêô) ùêô)
;; ;; -----------------(Even) -(ùêô)  -(double) -----------------(Sym)
;; ;; (-> (: $_ ‚Ñï) Type)      ‚Ñï     ‚Ñï         (=== ùêô (double ùêô))
;; ;; ----------------------------------------------------------(Cong)
;; ;;                (=== (Even ùêô) (Even (double ùêô)))
;; ;;
;; ;; TODO: use assertEqual once we support alpha-equivalence
;; ;; !(assertEqual
;; !(bc &kb
;;      Nil
;;      z
;;      (fromNumber 4)
;;      (: $prf (=== (Even ùêô) (Even (double (: ùêô ‚Ñï))))))
;;   ;; (: ((((Cong
;;   ;;        (: Even (-> (: $_ ‚Ñï) Type)))
;;   ;;       (: ùêô ‚Ñï))
;;   ;;      (: (double (: ùêô ‚Ñï)) ‚Ñï))
;;   ;;     (: (Sym (: double_base (=== (double (: ùêô ‚Ñï)) ùêô))) (=== ùêô (double (: ùêô ‚Ñï)))))
;;   ;;    (=== (Even ùêô) (Even (double (: ùêô ‚Ñï)))))

;; ;; Type check the proof that (double ùêô) is even
;; ;; TODO: use alpha-equivalence
;; ;; !(assertAlphaEqual
;;   !(bc &kb
;;       Nil
;;       z
;;       (fromNumber 6)
;;       (: ((Replace
;;            (: ((((Cong
;;                   (: Even $t1))
;;                  (: ùêô $t2))
;;                 (: (double (: ùêô $t3)) $t4))
;;                (: (Sym (: double_base $t5)) $t6))
;;               $t7))
;;           (: MkEvenZ $t8))
;;          (Even (double (: ùêô ‚Ñï)))))
;;   ;; (: ((Replace
;;   ;;      (: ((((Cong
;;   ;;             (: Even (-> (: $_ ‚Ñï) Type)))
;;   ;;            (: ùêô ‚Ñï))
;;   ;;           (: (double (: ùêô ‚Ñï)) ‚Ñï))
;;   ;;          (: (Sym (: double_base (=== (double (: ùêô ‚Ñï)) ùêô))) (=== ùêô (double (: ùêô ‚Ñï)))))
;;   ;;         (=== (Even ùêô) (Even (double (: ùêô ‚Ñï))))))
;;   ;;     (: MkEvenZ (Even ùêô)))
;;   ;;    (Even (double (: ùêô ‚Ñï)))))

;; ;; Prove that (double ùêô) is even.
;; ;;
;; ;; A possible proof of that is represented by the following proof tree:
;; ;;
;; ;;                               -(ùêô)      -----------------(double_base)
;; ;;                               ‚Ñï         (=== (double ùêô) ùêô)
;; ;; -----------------(Even) -(ùêô)  -(double) -----------------(Sym)
;; ;; (-> (: $_ ‚Ñï) Type)      ‚Ñï     ‚Ñï         (=== ùêô (double ùêô))
;; ;; ----------------------------------------------------------(Cong)  -------(MkEvenZ)
;; ;;                (=== (Even ùêô) (Even (double ùêô)))                   (Even ùêô)
;; ;;                ----------------------------------------------------------(Replace)
;; ;;                                       (Even (double ùêô))
;; ;;
;; ;; Or in MeTTa format:
;; ;;
;; ;; (: ((Replace ((((Cong Even) ùêô) (double ùêô)) (Sym double_base))) MkEvenZ) (Even (double ùêô)))
;; ;;
;; ;; Note that for this to run reasonable fast, proof abstraction must be disabled.
;; ;;
;; ;; TODO: re-enable with alpha-equivalence
;; ;; !(assertEqual
;;   !(bc &kb Nil z (fromNumber 6) (: $prf (Even (double (: ùêô ‚Ñï)))))
;;   ;; (: ((Replace
;;   ;;      (: ((((Cong
;;   ;;             (: Even (-> (: $_ ‚Ñï) Type)))
;;   ;;            (: ùêô ‚Ñï))
;;   ;;           (: (double (: ùêô ‚Ñï)) ‚Ñï))
;;   ;;          (: (Sym (: double_base (=== (double (: ùêô ‚Ñï)) ùêô)))
;;   ;;             (=== ùêô (double (: ùêô ‚Ñï)))))
;;   ;;         (=== (Even ùêô) (Even (double (: ùêô ‚Ñï))))))
;;   ;;     (: MkEvenZ (Even ùêô)))
;;   ;;    (Even (double (: ùêô ‚Ñï)))))

;; ;; Prove
;; ;;
;; ;; (-> (: Even (-> (: $_ ‚Ñï) Type))
;; ;;     (-> (: (double (ùêí $k)) ‚Ñï)
;; ;;         (-> (: (ùêí (ùêí (double $k))) ‚Ñï)
;; ;;             (-> (: $eq (=== (double (ùêí $k)) (ùêí (ùêí (double $k)))))
;; ;;                 (=== (Even (double (ùêí $k))) (Even (ùêí (ùêí (double $k)))))))))
;; ;;
;; ;; which should merely be Cong.
;; !(assertEqual
;;   (bc &kb Nil z (fromNumber 0)
;;       (: $prf (-> (: Even (-> (: $_ ‚Ñï) Type))
;;                   (-> (: (double (ùêí $k)) ‚Ñï)
;;                       (-> (: (ùêí (ùêí (double $k))) ‚Ñï)
;;                           (-> (: $eq (=== (double (ùêí $k)) (ùêí (ùêí (double $k)))))
;;                               (=== (Even (double (ùêí $k))) (Even (ùêí (ùêí (double $k)))))))))))
;;   (: Cong (-> (: Even (-> (: $_ ‚Ñï) Type))
;;               (-> (: (double (ùêí $k)) ‚Ñï)
;;                   (-> (: (ùêí (ùêí (double $k))) ‚Ñï)
;;                       (-> (: $eq (=== (double (ùêí $k)) (ùêí (ùêí (double $k)))))
;;                           (=== (Even (double (ùêí $k))) (Even (ùêí (ùêí (double $k)))))))))))

;; ;; Prove
;; ;;
;; ;; (-> (: (double (ùêí $k)) ‚Ñï)
;; ;;     (-> (: (ùêí (ùêí (double $k))) ‚Ñï)
;; ;;         (-> (: $eq (=== (double (ùêí $k)) (ùêí (ùêí (double $k)))))
;; ;;             (=== (Even (double (ùêí $k))) (Even (ùêí (ùêí (double $k))))))))
;; ;;
;; ;; which should be (Cong Even).
;; ;; TODO: re-enable after introducting assertAlphaEqual
;; ;; !(assertEqual
;;   (bc &kb Nil z (fromNumber 1)
;;       (: $prf (-> (: (double (ùêí $k)) ‚Ñï)
;;                   (-> (: (ùêí (ùêí (double $k))) ‚Ñï)
;;                       (-> (: $eq (=== (double (ùêí $k)) (ùêí (ùêí (double $k)))))
;;                           (=== (Even (double (ùêí $k))) (Even (ùêí (ùêí (double $k))))))))))
;;   ;; (: (Cong (: Even (-> (: $_ ‚Ñï) Type)))
;;   ;;    (-> (: (double (ùêí $k)) ‚Ñï)
;;   ;;        (-> (: (ùêí (ùêí (double $k))) ‚Ñï)
;;   ;;            (-> (: $eq (=== (double (ùêí $k)) (ùêí (ùêí (double $k)))))
;;   ;;                (=== (Even (double (ùêí $k))) (Even (ùêí (ùêí (double $k))))))))))

;; ;; Type annotate (Œª z (((Cong Even) (double (ùêí z))) (ùêí (ùêí (double z)))))
;; ;; TODO: re-enable once assertAlphaEqual is supported
;; ;; !(assertEqual
;;   !(add-type-annotation (Œª z (((Cong Even) (double (ùêí z))) (ùêí (ùêí (double z))))))
;;   ;; (Œª z (((Cong (: Even $a)) (: (double (: (ùêí (: z $b)) $c)) $d)) (: (ùêí (: (ùêí (: (double (: z $e)) $f)) $g)) $h))))

;; ;; Infer theorem of proof
;; ;;
;; ;; (Œª z (((Cong Even) (double (ùêí z))) (ùêí (ùêí (double z)))))
;; ;;
;; ;; which should be
;; ;;
;; ;; (-> (: $k ‚Ñï)
;; ;;     (-> (: $eq (=== (double (ùêí $k)) (ùêí (ùêí (double $k)))))
;; ;;         (=== (Even (double (ùêí $k))) (Even (ùêí (ùêí (double $k)))))))
;; ;;
;; ;; TODO: re-enable once assertAlphaEqual is supported
;; ;; !(assertEqual
;;   !(bc &kb Nil z (fromNumber 5)
;;       (: (Œª z (((Cong (: Even $a)) (: (double (: (ùêí (: z $b)) $c)) $d)) (: (ùêí (: (ùêí (: (double (: z $e)) $f)) $g)) $h)))
;;          $thrm))
;;   ;; (: (Œª z (((Cong (: Even (-> (: $_ ‚Ñï) Type))) (: (double (: (ùêí (: z ‚Ñï)) ‚Ñï)) ‚Ñï)) (: (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï)) ‚Ñï)))
;;   ;;    (-> (: z ‚Ñï)
;;   ;;        (-> (: $eq (=== (double (: (ùêí (: z ‚Ñï)) ‚Ñï)) (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï))))
;;   ;;            (=== (Even (double (: (ùêí (: z ‚Ñï)) ‚Ñï))) (Even (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï))))))))

;; ;; Prove that
;; ;;
;; ;; (-> (: $k ‚Ñï)
;; ;;     (-> (: $eq (=== (double (ùêí $k)) (ùêí (ùêí (double $k)))))
;; ;;         (=== (Even (double (ùêí $k))) (Even (ùêí (ùêí (double $k)))))))
;; ;;
;; ;; giving (Œª z (((Cong ...) ...) ...)) as clue, which could be
;; ;;
;; ;; (Œª z (((Cong Even) (double (ùêí z))) (ùêí (ùêí (double z)))))
;; ;; !(assertAlphaEqual
;;  !(bc &kb Nil z (fromNumber 5)
;;       (: (Œª z (((Cong $prf1) $prf2) $prf3))
;;          (-> (: z ‚Ñï)
;;              (-> (: $eq (=== (double (: (ùêí (: z ‚Ñï)) ‚Ñï)) (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï))))
;;                  (=== (Even (double (: (ùêí (: z ‚Ñï)) ‚Ñï))) (Even (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï))))))))
;;   ;; (: (Œª z (((Cong (: Even (-> (: $_ ‚Ñï) Type)))
;;   ;;           (: (double (: (ùêí (: z ‚Ñï)) ‚Ñï)) ‚Ñï))
;;   ;;          (: (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï)) ‚Ñï)))
;;   ;;    (-> (: z ‚Ñï)
;;   ;;        (-> (: $eq (=== (double (: (ùêí (: z ‚Ñï)) ‚Ñï)) (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï))))
;;   ;;            (=== (Even (double (: (ùêí (: z ‚Ñï)) ‚Ñï))) (Even (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï))))))))

;; ;; Prove
;; ;;
;; ;; (-> (: $k ‚Ñï)
;; ;;     (-> (: Even (-> (: $_ ‚Ñï) Type))
;; ;;         (-> (: (double (ùêí $k)) ‚Ñï)
;; ;;             (-> (: (ùêí (ùêí (double $k))) ‚Ñï)
;; ;;                 (-> (: $eq (=== (double (ùêí $k)) (ùêí (ùêí (double $k)))))
;; ;;                     (=== (Even (double (ùêí $k))) (Even (ùêí (ùêí (double $k))))))))))
;; ;;
;; ;; A possible proof could be
;; ;;
;; ;; (Œª $k Cong)
;; !(assertEqual
;;   (bc &kb Nil z (fromNumber 1)
;;       (: $prf
;;          (-> (: $k ‚Ñï)
;;              (-> (: Even (-> (: $_ ‚Ñï) Type))
;;                  (-> (: (double (: (ùêí (: $k ‚Ñï)) ‚Ñï)) ‚Ñï)
;;                      (-> (: (ùêí (: (ùêí (: (double (: $k ‚Ñï)) ‚Ñï)) ‚Ñï)) ‚Ñï)
;;                          (-> (: $eq (=== (double (: (ùêí (: $k ‚Ñï)) ‚Ñï)) (ùêí (: (ùêí (: (double (: $k ‚Ñï)) ‚Ñï)) ‚Ñï))))
;;                              (=== (Even (double (: (ùêí (: $k ‚Ñï)) ‚Ñï))) (Even (ùêí (: (ùêí (: (double (: $k ‚Ñï)) ‚Ñï)) ‚Ñï)))))))))))
;;   (: (Œª z Cong)
;;      (-> (: z ‚Ñï)
;;          (-> (: Even (-> (: $_ ‚Ñï) Type))
;;              (-> (: (double (: (ùêí (: z ‚Ñï)) ‚Ñï)) ‚Ñï)
;;                  (-> (: (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï)) ‚Ñï)
;;                      (-> (: $eq (=== (double (: (ùêí (: z ‚Ñï)) ‚Ñï)) (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï))))
;;                          (=== (Even (double (: (ùêí (: z ‚Ñï)) ‚Ñï))) (Even (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï)))))))))))

;; ;; Add type annotation to (Œª z ((((Cong Even) (double (ùêí z))) (ùêí (ùêí (double z)))) (double_rec z)))
;; ;; TODO: re-enable once we have assertAlphaEqual
;; !(assertEqual
;;   (add-type-annotation (Œª z ((((Cong Even) (double (ùêí z))) (ùêí (ùêí (double z)))) (double_rec z))))
;;   (Œª z ((((Cong (: Even $a)) (: (double (: (ùêí (: z $b)) $c)) $d)) (: (ùêí (: (ùêí (: (double (: z $e)) $f)) $g)) $h)) (: (double_rec (: z $i)) $j))))

;; ;; Prove
;; ;;
;; ;; (-> (: $k ‚Ñï)
;; ;;     (-> (: $eq (=== (double (ùêí $k)) (ùêí (ùêí (double $k)))))
;; ;;         (=== (Even (double (ùêí $k))) (Even (ùêí (ùêí (double $k)))))))
;; ;;
;; ;; giving (Œª z ...) as clue, which could be
;; ;;
;; ;; (Œª z (((Cong Even) (double (ùêí z))) (ùêí (ùêí (double z)))))
;; ;; !(assertAlphaEqual
;;   !(bc &kb Nil z (fromNumber 5)
;;        (: (Œª z $bdy)
;;           (-> (: z ‚Ñï)
;;               (-> (: $eq (=== (double (: (ùêí (: z ‚Ñï)) ‚Ñï)) (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï))))
;;                   (=== (Even (double (: (ùêí (: z ‚Ñï)) ‚Ñï))) (Even (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï))))))))
;;   ;; (: (Œª z (((Cong (: Even (-> (: $_ ‚Ñï) Type)))
;;   ;;           (: (double (: (ùêí (: z ‚Ñï)) ‚Ñï)) ‚Ñï))
;;   ;;          (: (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï)) ‚Ñï)))
;;   ;;    (-> (: z ‚Ñï)
;;   ;;        (-> (: $eq (=== (double (: (ùêí (: z ‚Ñï)) ‚Ñï)) (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï))))
;;   ;;            (=== (Even (double (: (ùêí (: z ‚Ñï)) ‚Ñï))) (Even (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï))))))))

;; ;; Prove
;; ;;
;; ;; (-> (: $k ‚Ñï)
;; ;;     (-> (: $eq (=== (double (ùêí $k)) (ùêí (ùêí (double $k)))))
;; ;;         (=== (Even (double (ùêí $k))) (Even (ùêí (ùêí (double $k)))))))
;; ;;
;; ;; which could be
;; ;;
;; ;; (Œª $k (((Cong Even) (double (ùêí $k))) (ùêí (ùêí (double $k)))))
;; ;;
;; ;; TODO: disabled because it takes too much RAM (over 256GB).
;; ;;
;; ;; TODO: re-enable once assertAlphaEqual is supported
;; ;; !(assertEqual
;;   !(bc &kb Nil z (fromNumber 5)
;;        (: $prf
;;           (-> (: z ‚Ñï)
;;               (-> (: $eq (=== (double (: (ùêí (: z ‚Ñï)) ‚Ñï)) (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï))))
;;                   (=== (Even (double (: (ùêí (: z ‚Ñï)) ‚Ñï))) (Even (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï))))))))

;; ;; Prove
;; ;;
;; ;; (-> (: z ‚Ñï)
;; ;;     (=== (double (: (ùêí (: z ‚Ñï)) ‚Ñï)) (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï))))
;; ;;
;; ;; which should merely be double_rec
;; !(assertEqual
;;   (bc &kb Nil z (fromNumber 0)
;;       (: $prf
;;          (-> (: z ‚Ñï)
;;              (=== (double (: (ùêí (: z ‚Ñï)) ‚Ñï)) (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï))))))
;;   (: double_rec (-> (: z ‚Ñï) (=== (double (: (ùêí (: z ‚Ñï)) ‚Ñï)) (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï))))))

;; ;; Check that
;; ;;
;; ;; (Œª z ((((Cong Even) (double (ùêí z))) (ùêí (ùêí (double z)))) (double_rec z)))
;; ;;
;; ;; is a proof of
;; ;;
;; ;; (-> (: $k ‚Ñï) (=== (Even (double (ùêí $k))) (Even (ùêí (ùêí (double $k))))))
;; !(assertEqual
;;   (bc &kb Nil z (fromNumber 6)
;;       (: (Œª z ((((Cong (: Even (-> (: $_ ‚Ñï) Type)))
;;                  (: (double (: (ùêí (: z $b)) $c)) $d))
;;                 (: (ùêí (: (ùêí (: (double (: z $e)) $f)) $g)) $h))
;;                (: (double_rec (: z $i)) $j)))
;;          (-> (: z ‚Ñï)
;;              (=== (Even (double (: (ùêí (: z ‚Ñï)) ‚Ñï))) (Even (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï)))))))
;;   (: (Œª z ((((Cong
;;               (: Even (-> (: $_ ‚Ñï) Type)))
;;              (: (double (: (ùêí (: z ‚Ñï)) ‚Ñï)) ‚Ñï))
;;             (: (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï)) ‚Ñï))
;;            (: (double_rec (: z ‚Ñï)) (=== (double (: (ùêí (: z ‚Ñï)) ‚Ñï)) (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï))))))
;;      (-> (: z ‚Ñï) (=== (Even (double (: (ùêí (: z ‚Ñï)) ‚Ñï))) (Even (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï)))))))

;; ;; Prove
;; ;;
;; ;; (-> (: $k ‚Ñï) (=== (Even (double (ùêí $k))) (Even (ùêí (ùêí (double $k))))))
;; ;;
;; ;; giving (Œª z ((((Cong $prf1) $prf2) $prf3) $prf4)) as clue
;; ;;
;; ;; A possible proof could be
;; ;;
;; ;; (Œª z ((((Cong Even) (double (ùêí z))) (ùêí (ùêí (double z)))) (double_rec z)))
;; ;;
;; ;; Beware that this can take half an hour.
;; ;;
;; !(bc &kb Nil z (fromNumber 6)
;;      (: (Œª z ((((Cong $prf1) $prf2) $prf3) $prf4))
;;         (-> (: z ‚Ñï)
;;             (=== (Even (double (: (ùêí (: z ‚Ñï)) ‚Ñï))) (Even (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï)))))))

;; ;; Prove
;; ;;
;; ;; (-> (: $k ‚Ñï) (=== (Even (double (ùêí $k))) (Even (ùêí (ùêí (double $k))))))
;; ;;
;; ;; giving (Œª z $bdy) as clue
;; ;;
;; ;; A possible proof could be
;; ;;
;; ;; (Œª z ((((Cong Even) (double (ùêí z))) (ùêí (ùêí (double z)))) (double_rec z)))
;; ;;
;; ;; TODO: disabled because it takes too much RAM
;; !(bc &kb Nil z (fromNumber 6)
;;      (: (Œª z $bdy)
;;         (-> (: z ‚Ñï)
;;             (=== (Even (double (: (ùêí (: z ‚Ñï)) ‚Ñï))) (Even (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï)))))))

;; ;; Check that
;; ;;
;; ;; (Œª z (Sym ((((Cong Even) (double (ùêí z))) (ùêí (ùêí (double z)))) (double_rec z))))
;; ;;
;; ;; is a proof of
;; ;;
;; ;; (-> (: $k ‚Ñï) (=== (Even (ùêí (ùêí (double $k)))) (Even (double (ùêí $k)))))
;; !(assertEqual
;;   (bc &kb Nil z (fromNumber 7)
;;       (: (Œª z (Sym (: ((((Cong (: Even (-> (: $_ ‚Ñï) Type)))
;;                          (: (double (: (ùêí (: z $b)) $c)) $d))
;;                         (: (ùêí (: (ùêí (: (double (: z $e)) $f)) $g)) $h))
;;                        (: (double_rec (: z $i)) $j)) $k)))
;;          (-> (: z ‚Ñï)
;;              (=== (Even (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï))) (Even (double (: (ùêí (: z ‚Ñï)) ‚Ñï)))))))
;;   (: (Œª z (Sym (: ((((Cong (: Even (-> (: $_ ‚Ñï) Type)))
;;                      (: (double (: (ùêí (: z ‚Ñï)) ‚Ñï)) ‚Ñï))
;;                     (: (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï)) ‚Ñï))
;;                    (: (double_rec (: z ‚Ñï)) (=== (double (: (ùêí (: z ‚Ñï)) ‚Ñï)) (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï)))))
;;                   (=== (Even (double (: (ùêí (: z ‚Ñï)) ‚Ñï))) (Even (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï)))))))
;;      (-> (: z ‚Ñï) (=== (Even (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï))) (Even (double (: (ùêí (: z ‚Ñï)) ‚Ñï)))))))

;; ;; Check that
;; ;;
;; ;; (Œª z (Replace (Sym ((((Cong Even) (double (ùêí z))) (ùêí (ùêí (double z)))) (double_rec z)))))
;; ;;
;; ;; is a proof of
;; ;;
;; ;; (-> (: z ‚Ñï) (-> (: $e (Even (ùêí (ùêí (double z))))) (Even (double (ùêí z)))))
;; ;;
;; ;; corresponding to the following proof tree
;; ;;
;; ;;                                                   -(z)
;; ;;                                                   ‚Ñï
;; ;;                                         -(z)      -(double)
;; ;;                                         ‚Ñï          ‚Ñï
;; ;;                                         -(ùêí)       -(ùêí)                      -(z)
;; ;;                                         ‚Ñï          ‚Ñï                         ‚Ñï
;; ;;                -----------------(Even)  -(double)  -(ùêí)  --------------------------------------(double_rec)
;; ;;                (-> (: $_ ‚Ñï) Type)       ‚Ñï          ‚Ñï     (=== (double (ùêí z)) (ùêí (ùêí (double z))))                         
;; ;;                --------------------------------------------------------------------------------(Cong)
;; ;;                (=== (Even (double (ùêí z))) (Even (ùêí (ùêí (double z)))))                                 
;; ;;                ----------------------------------------------------(Sym)                       
;; ;;                (=== (Even (ùêí (ùêí (double z)))) (Even (double (ùêí z))))                           
;; ;; -(z)         ----------------------------------------------------------(Replace)
;; ;; ‚Ñï            (-> (: $e (Even (ùêí (ùêí (double z))))) (Even (double (ùêí z))))
;; ;; -----------------------------------------------------------------------(Œª)
;; ;; (-> (: z ‚Ñï) (-> (: $e (Even (ùêí (ùêí (double z))))) (Even (double (ùêí z)))))
;; ;;
;; ;; Before checking, let us type annotate the proof (disabled till assertAlphaEqual is support)
;; ;; !(assertAlphaEqual
;; ;;   (add-type-annotation (Œª z (Replace (Sym ((((Cong Even) (double (ùêí z))) (ùêí (ùêí (double z)))) (double_rec z))))))
;; ;;   (Œª z (Replace (: (Sym (: ((((Cong (: Even $a)) (: (double (: (ùêí (: z $b)) $c)) $d)) (: (ùêí (: (ùêí (: (double (: z $e)) $f)) $g)) $h)) (: (double_rec (: z $i)) $j)) $k)) $l))))
;; !(assertEqual
;;   (bc &kb Nil z (fromNumber 8)
;;       (: (Œª z
;;            (Replace
;;             (: (Sym
;;                 (: ((((Cong (: Even (-> (: $_ ‚Ñï) Type)))
;;                       (: (double (: (ùêí (: z $b)) $c)) $d))
;;                      (: (ùêí (: (ùêí (: (double (: z $e)) $f)) $g)) $h))
;;                     (: (double_rec (: z $i)) $j))
;;                    $k))
;;                $l)))
;;          (-> (: z ‚Ñï) (-> (: $prf (Even (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï)))) (Even (double (: (ùêí (: z ‚Ñï)) ‚Ñï)))))))
;;   (: (Œª z
;;        (Replace
;;         (: (Sym
;;             (: ((((Cong (: Even (-> (: $_ ‚Ñï) Type)))
;;                   (: (double (: (ùêí (: z ‚Ñï)) ‚Ñï)) ‚Ñï))
;;                  (: (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï)) ‚Ñï))
;;                 (: (double_rec (: z ‚Ñï)) (=== (double (: (ùêí (: z ‚Ñï)) ‚Ñï)) (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï)))))
;;                (=== (Even (double (: (ùêí (: z ‚Ñï)) ‚Ñï))) (Even (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï))))))
;;            (=== (Even (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï))) (Even (double (: (ùêí (: z ‚Ñï)) ‚Ñï)))))))
;;      (-> (: z ‚Ñï) (-> (: $prf (Even (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï)))) (Even (double (: (ùêí (: z ‚Ñï)) ‚Ñï)))))))

;; ;; Prove that if (double z) is even then (ùêí (ùêí (double z))) is even.
;; !(assertEqual
;;   (bc &kb Nil z (fromNumber 3)
;;       (: (Œª z (Œª (s z) $bdy))
;;          (-> (: z ‚Ñï)
;;              (-> (: (s z) (Even (double (: z ‚Ñï))))
;;                  (Even (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï)))))))
;;   (: (Œª z
;;        (Œª (s z)
;;          (MkEvenSS (: (s z) (Even (double (: z ‚Ñï)))))))
;;      (-> (: z ‚Ñï)
;;          (-> (: (s z) (Even (double (: z ‚Ñï))))
;;              (Even (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï)))))))

;; ;; Prove that (double (ùêí z)) is even, assuming that
;; ;;
;; ;; (: z ‚Ñï)
;; ;; (: (s z) (Even (double z)))
;; ;; (: (s (s (s z))) (=== (Even (ùêí (ùêí (double $k)))) (Even (double (ùêí $k)))))
;; ;;
;; ;; The proof may correspond to the proof tree below
;; ;;
;; ;;                                                                    ----------------(s z)
;; ;;                                                                    (Even (double z))
;; ;; ----------------------------------------------------(s (s z))  ------------------------(MkEvenSS)
;; ;; (=== (Even (ùêí (ùêí (double z)))) (Even (double (ùêí z))))          (Even (ùêí (ùêí (double z))))
;; ;; -----------------------------------------------------------------------------------------(Replace)
;; ;;                                  (Even (double (ùêí z)))
;; !(assertEqual
;;   (bc &kb
;;       (Cons (: z ‚Ñï)
;;             (Cons (: (s z) (Even (double (: z ‚Ñï))))
;;                   (Cons (: (s (s z)) (=== (Even (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï))) (Even (double (: (ùêí (: z ‚Ñï)) ‚Ñï)))))
;;                         Nil)))
;;       z
;;       (fromNumber 2)
;;       (: ((Replace
;;            (: (s (s z)) (=== (Even (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï))) (Even (double (: (ùêí (: z ‚Ñï)) ‚Ñï))))))
;;           (: (MkEvenSS (: (s z) (Even (double (: z ‚Ñï))))) (Even (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï)))))
;;          (Even (double (: (ùêí (: z ‚Ñï)) ‚Ñï)))))
;;   (: ((Replace
;;        (: (s (s z)) (=== (Even (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï))) (Even (double (: (ùêí (: z ‚Ñï)) ‚Ñï))))))
;;       (: (MkEvenSS (: (s z) (Even (double (: z ‚Ñï))))) (Even (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï)))))
;;      (Even (double (: (ùêí (: z ‚Ñï)) ‚Ñï)))))

;; ;; Like above but the first hypothesis is wrapped in a lambda abstraction
;; !(assertEqual
;;   (bc &kb
;;       (Cons (: (s z) (Even (double (: z ‚Ñï))))
;;             (Cons (: (s (s z)) (=== (Even (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï))) (Even (double (: (ùêí (: z ‚Ñï)) ‚Ñï)))))
;;                         Nil))
;;       z
;;       (fromNumber 3)
;;       (: (Œª z
;;            ((Replace
;;              (: (s (s z)) (=== (Even (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï))) (Even (double (: (ùêí (: z ‚Ñï)) ‚Ñï))))))
;;             (: (MkEvenSS (: (s z) (Even (double (: z ‚Ñï))))) (Even (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï))))))
;;          (-> (: z ‚Ñï)
;;              (Even (double (: (ùêí (: z ‚Ñï)) ‚Ñï))))))
;;   (: (Œª z
;;        ((Replace
;;          (: (s (s z)) (=== (Even (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï))) (Even (double (: (ùêí (: z ‚Ñï)) ‚Ñï))))))
;;         (: (MkEvenSS (: (s z) (Even (double (: z ‚Ñï))))) (Even (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï))))))
;;      (-> (: z ‚Ñï) (Even (double (: (ùêí (: z ‚Ñï)) ‚Ñï))))))

;; ;; Like above but the first 2 hypotheses are wrapped in lambda abstractions
;; !(assertEqual
;;   (bc &kb
;;       (Cons (: (s (s z)) (=== (Even (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï))) (Even (double (: (ùêí (: z ‚Ñï)) ‚Ñï)))))
;;             Nil)
;;       z
;;       (fromNumber 4)
;;       (: (Œª z
;;            (Œª (s z)
;;              ((Replace
;;                (: (s (s z)) (=== (Even (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï))) (Even (double (: (ùêí (: z ‚Ñï)) ‚Ñï))))))
;;               (: (MkEvenSS (: (s z) (Even (double (: z ‚Ñï))))) (Even (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï)))))))
;;          (-> (: z ‚Ñï)
;;              (-> (: (s z) (Even (double (: z ‚Ñï))))
;;                  (Even (double (: (ùêí (: z ‚Ñï)) ‚Ñï)))))))
;;   (: (Œª z
;;        (Œª (s z)
;;          ((Replace
;;            (: (s (s z)) (=== (Even (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï))) (Even (double (: (ùêí (: z ‚Ñï)) ‚Ñï))))))
;;           (: (MkEvenSS (: (s z) (Even (double (: z ‚Ñï))))) (Even (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï)))))))
;;      (-> (: z ‚Ñï) (-> (: (s z) (Even (double (: z ‚Ñï)))) (Even (double (: (ùêí (: z ‚Ñï)) ‚Ñï)))))))

;; NEXT: try to understand why the following does not work.

;; Like above but all hypotheses are wrapped in lambda abstractions
!(assertEqual
  (bc &kb
      Nil
      z
      (fromNumber 5)
      (: (Œª z
           (Œª (s z)
             (Œª (s (s z))
               (: ((Replace
                    (: (s (s z)) (=== (Even (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï))) (Even (double (: (ùêí (: z ‚Ñï)) ‚Ñï))))))
                   (: (MkEvenSS (: (s z) (Even (double (: z ‚Ñï))))) (Even (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï)))))
                  (Even (double (: (ùêí (: z ‚Ñï)) ‚Ñï)))))))
         (-> (: z ‚Ñï)
             (-> (: (s z) (Even (double (: z ‚Ñï))))
                 (-> (: (s (s z)) (=== (Even (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï))) (Even (double (: (ùêí (: z ‚Ñï)) ‚Ñï)))))
                     (Even (double (: (ùêí (: z ‚Ñï)) ‚Ñï))))))))
  (: (Œª z
       (Œª (s z)
         (Œª (s (s z))
           (: ((Replace
                (: (s (s z)) (=== (Even (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï))) (Even (double (: (ùêí (: z ‚Ñï)) ‚Ñï))))))
               (: (MkEvenSS (: (s z) (Even (double (: z ‚Ñï))))) (Even (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï)))))
              (Even (double (: (ùêí (: z ‚Ñï)) ‚Ñï)))))))
     (-> (: z ‚Ñï)
         (-> (: (s z) (Even (double (: z ‚Ñï))))
             (-> (: (s (s z)) (=== (Even (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï))) (Even (double (: (ùêí (: z ‚Ñï)) ‚Ñï)))))
                 (Even (double (: (ùêí (: z ‚Ñï)) ‚Ñï))))))))

;; ;; Check that
;; ;;
;; ;; (Œª z (Œª (s z) ((Replace (Sym ((((Cong Even) (double (ùêí z))) (ùêí (ùêí (double z)))) (double_rec z)))) (MkEvenSS (s z)))))
;; ;;
;; ;; is a proof that if (double k) is even, then (double (ùêí k)) is even.
;; ;;
;; ;; See the corresponding proof tree below
;; ;;
;; ;;                                                                                 -(z)
;; ;;                                                                                 ‚Ñï
;; ;;                                                                      -(z)      -(double)
;; ;;                                                                      ‚Ñï          ‚Ñï
;; ;;                                                                      -(ùêí)       -(ùêí)                      -(z)
;; ;;                                                                      ‚Ñï          ‚Ñï                         ‚Ñï
;; ;;                                               -----------------(Even)  -(double)  -(ùêí)  --------------------------------------(double_rec)
;; ;;                                               (-> (: $_ ‚Ñï) Type)       ‚Ñï          ‚Ñï     (=== (double (ùêí z)) (ùêí (ùêí (double z))))                         
;; ;;                                               ----------------------------------------------------------------------------------(Cong)  ----------------(s z)
;; ;;                                               (=== (Even (double (ùêí $k))) (Even (ùêí (ùêí (double $k)))))                                   (Even (double z))
;; ;;                                               ------------------------------------------------------(Sym)                       ------------------------(MkEvenSS)
;; ;;                                               (=== (Even (ùêí (ùêí (double $k)))) (Even (double (ùêí $k))))                           (Even (ùêí (ùêí (double z))))
;; ;;              ----------------(s z)            ----------------------------------------------------------------------------------------------------------(Replace)
;; ;;              (Even (double z))                (Even (double (ùêí z)))
;; ;; -(z)         -----------------------------------------------------(Œª)
;; ;; ‚Ñï            (-> (: (s z) (Even (double z))) (Even (double (ùêí z))))
;; ;; ------------------------------------------------------------------(Œª)
;; ;; (-> (: z ‚Ñï) (-> (: (s z) (Even (double z))) (Even (double (ùêí z)))))
;; ;;
;; ;; Before checking, let us type annotate the proof (disabled till assertAlphaEqual is supported)
;; ;; !(assertAlphaEqual
;; ;;   (add-type-annotation (Œª z (Œª (s z) ((Replace (Sym ((((Cong Even) (double (ùêí z))) (ùêí (ùêí (double z)))) (double_rec z)))) (MkEvenSS (s z))))))
;; ;;   (Œª z (Œª (s z) ((Replace (: (Sym (: ((((Cong (: Even $a)) (: (double (: (ùêí (: z $b)) $c)) $d)) (: (ùêí (: (ùêí (: (double (: z $e)) $f)) $g)) $h)) (: (double_rec (: z $i)) $j)) $k)) $l)) (: (MkEvenSS (: (s z) $m)) $n)))))
;; !(bc &kb Nil z (fromNumber 12)
;;   (: (Œª z
;;        (Œª (s z)
;;          ((Replace
;;            (: (Sym
;;                (: ((((Cong (: Even (-> (: $_ ‚Ñï) Type)))
;;                      (: (double (: (ùêí (: z ‚Ñï)) ‚Ñï)) ‚Ñï))
;;                     (: (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï)) ‚Ñï))
;;                    (: (double_rec (: z ‚Ñï)) (=== (double (: (ùêí (: z ‚Ñï)) ‚Ñï)) (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï)))))
;;                   (=== (Even (double (: (ùêí (: z ‚Ñï)) ‚Ñï))) (Even (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï))))))
;;               (=== (Even (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï))) (Even (double (: (ùêí (: z ‚Ñï)) ‚Ñï))))))
;;           (: (MkEvenSS (: (s z) (Even (double (: z ‚Ñï))))) (Even (ùêí (: (ùêí (: (double (: z ‚Ñï)) ‚Ñï)) ‚Ñï)))))))
;;      (-> (: z ‚Ñï)
;;          (-> (: (s z) (Even (double (: z ‚Ñï))))
;;              (Even (double (: (ùêí (: z ‚Ñï)) ‚Ñï)))))))
;;      ;; (: (Œª z
;;      ;;      (Œª (s z)
;;      ;;        ((Replace
;;      ;;          (: (Sym
;;      ;;              (: ((((Cong (: Even $a))
;;      ;;                    (: (double (: (ùêí (: z $b)) $c)) $d))
;;      ;;                   (: (ùêí (: (ùêí (: (double (: z $e)) $f)) $g)) $h))
;;      ;;                  (: (double_rec (: z $i)) $j))
;;      ;;                 $k))
;;      ;;             $l))
;;      ;;         (: (MkEvenSS (: (s z) $m)) $n))))
;;      ;;    $thrm))

;; ;; ;; NEXT: this fails with the following error
;; ;; ;;
;; ;; ;; thread '<unnamed>' panicked at /home/nilg/Work/TrueAGI/hyperon-experimental/lib/src/atom/matcher.rs:199:14:
;; ;; ;; Unexpected state
;; ;; ;; note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
;; ;; ;; fatal runtime error: Rust panics must be rethrown
;; ;; ;; Aborted (core dumped)
;; ;; (bc &kb (: $prf (-> (: $k ‚Ñï) (-> (: $e (Even (double $k))) (Even (double (ùêí $k)))))) (fromNumber 8))

;; ;; ;; ;; Prove that for all x, (double x) is even
;; ;; ;; (bc &kb (: $prf (-> (: $x ‚Ñï) (Even (double $x)))) (fromNumber 3))
